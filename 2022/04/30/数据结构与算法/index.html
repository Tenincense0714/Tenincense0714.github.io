<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">数据结构与算法 | TenIncense</title>
  
    <link rel="shortcut icon" href="https://tenincense-1309094827.cos.ap-guangzhou.myqcloud.com/image/202205291139260.jpg">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "さくら荘そのTenIncense";
  mashiro_option.author_name = "TenIncense";
  mashiro_option.site_url = "https://github.com/Tenincense0714/";
  mashiro_option.v_appId = "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz";
  mashiro_option.v_appKey = "mgOpfzbkHYqU92CV4IDlAUHQ";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(1).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(2).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(3).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(4).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(5).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(6).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(7).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(8).jpg.webp".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://github.com/Tenincense0714/">
          <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6https://tenincense-1309094827.cos.ap-guangzhou.myqcloud.com/image/202205291139260.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>须知少年凌云志，曾许人间第一流</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/honjun" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="sina">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/sina.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="wangyiyun">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wangyiyun.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">さくら荘その</span>
            <span class="shironeko">TenIncense</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/悦读/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/图集/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          图集
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Lab
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/client/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-android faa-vertical" aria-hidden="true"></i>
                    客户端
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
          <header class="entry-header">
            <h1 class="entry-title">数据结构与算法</h1>
            <p class="entry-census">&nbsp;·&nbsp;2022-4-30&nbsp;·&nbsp;<span id="busuanzi_value_page_pv"></span>次阅读</p></p>

            <hr>
          </header>
        
        <div class="entry-content">
          <h2 id="一、数据结构和算法概述"><a href="#一、数据结构和算法概述" class="headerlink" title="一、数据结构和算法概述"></a>一、数据结构和算法概述</h2><h3 id="1-1什么是数据结构？"><a href="#1-1什么是数据结构？" class="headerlink" title="1.1什么是数据结构？"></a>1.1什么是数据结构？</h3><ul>
<li>官方解释：</li>
</ul>
<p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。</p>
<ul>
<li>大白话：</li>
</ul>
<p>数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据</p>
<hr>
<h3 id="1-2数据结构分类"><a href="#1-2数据结构分类" class="headerlink" title="1.2数据结构分类"></a>1.2数据结构分类</h3><p>传统上，我们可以把数据结构分为<code>逻辑结构</code>和<code>物理结构</code>两大类。</p>
<h4 id="逻辑结构分类："><a href="#逻辑结构分类：" class="headerlink" title="逻辑结构分类："></a>逻辑结构分类：</h4><p>逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是</p>
<p>我们后面课题中需要关注和讨论的问题。</p>
<p>a.<code>集合结构</code>：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204301236852.png" alt></p>
<p>b.<code>线性结构</code>：线性结构中的数据元素之间存在<strong>一对一</strong>的关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204301237497.png" alt></p>
<p>c.<code>树形结构</code>：树形结构中的数据元素之间存在<strong>一对多</strong>的层次关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204301237299.png" alt></p>
<p>d.<code>图形结构</code>：图形结构的数据元素是<strong>多对多</strong>的关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204301237173.png" alt></p>
<h4 id="物理结构分类："><a href="#物理结构分类：" class="headerlink" title="物理结构分类："></a>物理结构分类：</h4><p>逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。</p>
<p><code>顺序存储结构</code>：</p>
<p>把数据元素放到<strong>地址连续</strong>的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204301239615.png" alt></p>
<p>顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中，此时就需要链式存储结构。</p>
<p><code>链式存储结构</code>：</p>
<p>是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个<code>指针</code>存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204301240450.png" alt></p>
<hr>
<h3 id="1-3什么是算法？"><a href="#1-3什么是算法？" class="headerlink" title="1.3什么是算法？"></a>1.3什么是算法？</h3><ul>
<li>官方解释：</li>
</ul>
<p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。</p>
<ul>
<li>大白话：</li>
</ul>
<p>根据一定的条件，对一些数据进行计算，得到需要的结果。</p>
<hr>
<h3 id="1-4算法初体验"><a href="#1-4算法初体验" class="headerlink" title="1.4算法初体验"></a>1.4算法初体验</h3><p>在生活中，我们如果遇到某个问题，常常解决方案不是唯一的。</p>
<p>例如从西安到北京，如何去？会有不同的解决方案，我们可以坐飞机，可以坐火车，可以坐汽车，甚至可以步行，不同的解决方案带来的时间成本和金钱成本是不一样的，比如坐飞机用的时间最少，但是费用最高，步行费用最低，但时间最长。</p>
<p>再例如在北京二环内买一套四合院，如何付款？也会有不同的解决方案，可以一次性现金付清，也可以通过银行做按揭。这两种解决方案带来的成本也不一样，一次性付清，虽然当时出的钱多，压力大，但是没有利息，按揭虽然当时出的钱少，压力比较小，但是会有利息，而且30年的总利息几乎是贷款额度的一倍，需要多付钱。</p>
<p>在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。总体上，一个优秀的算法追求以下两个目标：</p>
<ol>
<li><p><code>花最少的时间完成需求</code>；</p>
</li>
<li><p><code>占用最少的内存空间完成需求</code>；</p>
</li>
</ol>
<p>下面我们用一些实际案例体验一些算法。</p>
<p><strong>需求1</strong>：</p>
<p>计算1到100的和。</p>
<p>第一种解法：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum = 0;
  int n=100;
  for (int i = 1; i &lt;= n; i++) {
      sum += i;
    }
    System.out.println(&quot;sum=&quot; + sum);
}</code></pre>
<p>第二种解法：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum = 0;
  int n=100;
  sum = (n+1)*n/2;
  System.out.println(&quot;sum=&quot;+sum);
}</code></pre>
<p>第一种解法要完成需求，要完成以下几个动作：</p>
<ol>
<li><p>定义两个整型变量；</p>
</li>
<li><p>执行100次加法运算；</p>
</li>
<li><p>打印结果到控制台；</p>
</li>
</ol>
<p>第二种解法要完成需求，要完成以下几个动作：</p>
<ol>
<li><p>定义两个整型变量；</p>
</li>
<li><p>执行1次加法运算，1次乘法运算，一次除法运算，总共3次运算；</p>
</li>
<li><p>打印结果到控制台；</p>
</li>
</ol>
<p>很明显，第二种算法完成需求，花费的时间更少一些。</p>
<p><strong>需求2</strong>：</p>
<p>计算10的阶乘</p>
<p>第一种解法：</p>
<pre><code class="java">public class Test {
  public static void main(String[] args) {
    //测试，计算10的阶乘
    long result = fun1(10);
    System.out.println(result);
  }
  //计算n的阶乘
  public static long fun1(long n){
    if (n==1){
        return 1;
      }
    return n*fun1(n-1);
  }
}</code></pre>
<p>第二种解法：</p>
<pre><code class="java">public class Test {
  public static void main(String[] args) {
    //测试，计算10的阶乘
    long result = fun2(10);
    System.out.println(result);
  }
  //计算n的阶乘
  public static long fun2(long n){
    int result=1;
    for (long i = 1; i &lt;= n; i++) {
        result*=i;
      }
      return result;
  }
}</code></pre>
<p>第一种解法，使用递归完成需求，fun1方法会执行10次，并且第一次执行未完毕，调用第二次执行，第二次执行未完毕，调用第三次执行…最终，最多的时候，需要在栈内存同时开辟10块内存分别执行10个fun1方法。</p>
<p>第二种解法，使用for循环完成需求，fun2方法只会执行一次，最终，只需要在栈内存开辟一块内存执行fun2方法即可。</p>
<p>很明显，第二种算法完成需求，占用的内存空间更小。</p>
<hr>
<hr>
<h2 id="二、算法分析"><a href="#二、算法分析" class="headerlink" title="二、算法分析"></a>二、算法分析</h2><p>一、算法分析</p>
<p>前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。</p>
<h3 id="1-1算法的时间复杂度分析"><a href="#1-1算法的时间复杂度分析" class="headerlink" title="1.1算法的时间复杂度分析"></a>1.1算法的时间复杂度分析</h3><p>我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢？</p>
<p><strong>事后分析估算方法：</strong> </p>
<p>比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不</p>
<p>错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设</p>
<p>计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率</p>
<p>的高低，但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完</p>
<p>了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别</p>
<p>导致测试的结果差异也很大。</p>
<pre><code class="java">public static void main(String[] args) {
  long start = System.currentTimeMillis();
  int sum = 0;
  int n=100;
  for (int i = 1; i &lt;= n; i++) {
      sum += i;
  }
  System.out.println(&quot;sum=&quot; + sum);
  long end = System.currentTimeMillis();
  System.out.println(end-start);
}</code></pre>
<p><strong>事前分析估算方法：</strong> </p>
<p>在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机</p>
<p>上运行所消耗的时间取决于下列因素：</p>
<ol>
<li><p>算法采用的策略和方案；</p>
</li>
<li><p>编译产生的代码质量；</p>
</li>
<li><p>问题的输入规模(所谓的问题输入规模就是输入量的多少)；</p>
</li>
<li><p>机器执行指令的速度；</p>
</li>
</ol>
<p>由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。</p>
<p>如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。</p>
<p>我么再次以之前的求和案例为例，进行分析。</p>
<p><strong>需求</strong>：</p>
<p>计算1到100的和。</p>
<p>第一种解法：</p>
<pre><code class="java">如果输入量为n为1，则需要计算1次；
如果输入量n为1亿，则需要计算1亿次；
public static void main(String[] args) {
  int sum = 0;//执行1次
  int n=100;//执行1次
  for (int i = 1; i &lt;= n; i++) {//执行了n+1次
      sum += i;//执行了n次
  }
  System.out.println(&quot;sum=&quot; + sum);
}</code></pre>
<p>第二种解法：</p>
<pre><code class="java">如果输入量为n为1，则需要计算1次；
如果输入量n为1亿，则需要计算1次；
public static void main(String[] args) {
  int sum = 0;//执行1次
  int n=100;//执行1次
  sum = (n+1)*n/2;//执行1次
  System.out.println(&quot;sum=&quot;+sum);
}</code></pre>
<p>因此，当输入规模为n时，第一种算法执行了1+1+(n+1)+n=2n+3次；第二种算法执行了1+1+1=3次。如果我们把第一种算法的循环体看做是一个整体，忽略结束条件的判断，那么其实这两个算法运行时间的差距就是n和1的差距。</p>
<p>为什么循环判断在算法1里执行了n+1次，看起来是个不小的数量，但是却可以忽略呢？我们来看下一个例子：</p>
<p><strong>需求</strong>：</p>
<p>计算100个1+100个2+100个3+…100个100的结果</p>
<p>代码：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum=0;
  int n=100;
  for (int i = 1; i &lt;=n ; i++) {
      for (int j = 1; j &lt;=n ; j++) {
          sum+=i;
      }
  }
  System.out.println(&quot;sum=&quot;+sum);
}</code></pre>
<p>上面这个例子中，如果我们要精确的研究循环的条件执行了多少次，是一件很麻烦的事情，并且，由于真正计算和的代码是内循环的循环体，所以，在研究算法的效率时，我们只考虑核心代码的执行次数，这样可以简化分析。</p>
<p>我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象(规律)，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。</p>
<p>我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把<code>核心操作的次数</code>和<code>输入规模</code>关联起来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302103542.png" alt></p>
<h4 id="1-1-1-函数渐近增长"><a href="#1-1-1-函数渐近增长" class="headerlink" title="1.1.1 函数渐近增长"></a>1.1.1 函数渐近增长</h4><p><strong>概念</strong>：</p>
<p>给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。</p>
<p>概念似乎有点艰涩难懂，那接下来我们做几个测试。</p>
<p><strong>测试一</strong>：</p>
<p>假设四个算法的输入规模都是n：</p>
<ol>
<li><p>算法A1要做2n+3次操作，可以这么理解：先执行n次循环，执行完毕后，再有一个n次循环，最后有3次运算；</p>
</li>
<li><p>算法A2要做2n次操作；</p>
</li>
<li><p>算法B1要做3n+1次操作，可以这个理解：先执行n次循环，再执行一个n次循环，再执行一个n次循环，最后有1次运算。</p>
</li>
<li><p>算法B2要做3n次操作；</p>
</li>
</ol>
<p>那么，上述算法，哪一个更快一些呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302104259.png" alt></p>
<p>通过数据表格，比较算法A1和算法B1：</p>
<p> 当输入规模n=1时，A1需要执行5次，B1需要执行4次，所以A1的效率比B1的效率低；</p>
<p> 当输入规模n=2时，A1需要执行7次，B1需要执行7次，所以A1的效率和B1的效率一样；</p>
<p> 当输入规模n&gt;2时，A1需要的执行次数一直比B1需要执行的次数少，所以A1的效率比B1的效率高；</p>
<p>所以我们可以得出结论：</p>
<p><strong>当输入规模n&gt;2时，算法A1的渐近增长小于算法B1 的渐近增长</strong></p>
<p>通过观察折线图，我们发现，随着输入规模的增大，算法A1和算法A2逐渐重叠到一块，算法B1和算法B2逐渐重叠到一块，所以我们得出结论：</p>
<p><strong>随着输入规模的增大，算法的常数操作可以忽略不计</strong></p>
<p><strong>测试二</strong>：</p>
<p>假设四个算法的输入规模都是n：</p>
<ol>
<li><p>算法C1需要做4n+8次操作</p>
</li>
<li><p>算法C2需要做n次操作</p>
</li>
<li><p>算法D1需要做2n^2次操作</p>
</li>
<li><p>算法D2需要做n^2次操作</p>
</li>
</ol>
<p>那么上述算法，哪个更快一些？</p>
<p>![image-20220430210626446](/Users/shixiang/Library/Application Support/typora-user-images/image-20220430210626446.png)</p>
<p>通过数据表格，对比算法C1和算法D1：</p>
<p> 当输入规模n&lt;=3时，算法C1执行次数多于算法D1，因此算法C1效率低一些；</p>
<p> 当输入规模n&gt;3时，算法C1执行次数少于算法D1，因此，算法D2效率低一些，</p>
<p>所以，总体上，算法C1要优于算法D1.</p>
<p>通过折线图，对比对比算法C1和C2：</p>
<p> 随着输入规模的增大，算法C1和算法C2几乎重叠</p>
<p>通过折线图，对比算法C系列和算法D系列：</p>
<p> 随着输入规模的增大，即使去除n^2前面的常数因子，D系列的次数要远远高于C系列。</p>
<p>因此，可以得出结论：</p>
<p><strong>随着输入规模的增大，与最高次项相乘的常数可以忽略</strong></p>
<p><strong>测试三</strong>：</p>
<p>假设四个算法的输入规模都是n：</p>
<p>算法E1:</p>
<p>2n^2+3n+1;</p>
<p>算法E2：</p>
<p>n^2</p>
<p>算法F1：</p>
<p>2n^3+3n+1</p>
<p>算法F2：</p>
<p>n^3</p>
<p>那么上述算法，哪个更快一些？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302108702.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302108838.png" alt></p>
<p>通过数据表格，对比算法E1和算法F1：</p>
<p> 当n=1时，算法E1和算法F1的执行次数一样；</p>
<p> 当n&gt;1时，算法E1的执行次数远远小于算法F1的执行次数；</p>
<p> 所以算法E1总体上是由于算法F1的。</p>
<p>通过折线图我们会看到，算法F系列随着n的增长会变得特块，算法E系列随着n的增长相比较算法F来说，变得比较慢，所以可以得出结论：</p>
<p><strong>最高次项的指数大的，随着n的增长，结果也会变得增长特别快</strong></p>
<p><strong>测试四</strong>：</p>
<p>假设五个算法的输入规模都是n：</p>
<p>算法G：</p>
<p>n^3;</p>
<p>算法H:</p>
<p>n^2;</p>
<p>算法I：</p>
<p>n:</p>
<p>算法J：</p>
<p>logn</p>
<p>算法K:</p>
<p>1</p>
<p>那么上述算法，哪个效率更高呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302110175.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302110107.png" alt></p>
<p>通过观察数据表格和折线图，很容易可以得出结论：</p>
<p><strong>算法函数中n最高次幂越小，算法效率越高</strong></p>
<p>总上所述，在我们比较算法随着输入规模的增长量时，可以有以下规则：</p>
<ol>
<li><p><strong>算法函数中的常数可以忽略；</strong></p>
</li>
<li><p><strong>算法函数中最高次幂的常数因子可以忽略；</strong></p>
</li>
<li><p><strong>算法函数中最高次幂越小，算法效率越高。</strong></p>
</li>
</ol>
<hr>
<h4 id="1-1-2算法时间复杂度"><a href="#1-1-2算法时间复杂度" class="headerlink" title="1.1.2算法时间复杂度"></a>1.1.2算法时间复杂度</h4><h5 id="1-1-2-1-大O记法"><a href="#1-1-2-1-大O记法" class="headerlink" title="1.1.2.1 大O记法"></a>1.1.2.1 大O记法</h5><p><strong>定义</strong>：</p>
<p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。</p>
<p>在这里，我们需要明确一个事情：<strong>执行次数=执行时间</strong></p>
<p>用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。</p>
<p>下面我们使用大O表示法来表示一些求和算法的时间复杂度：</p>
<p>算法一：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum = 0;//执行1次
  int n=100;//执行1次
  sum = (n+1)*n/2;//执行1次
  System.out.println(&quot;sum=&quot;+sum);
}</code></pre>
<p>算法二：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum = 0;//执行1次
  int n=100;//执行1次
  for (int i = 1; i &lt;= n; i++) {
      sum += i;//执行了n次
  }
  System.out.println(&quot;sum=&quot; + sum);
}</code></pre>
<p>算法三：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum=0;//执行1次
  int n=100;//执行1次
  for (int i = 1; i &lt;=n ; i++) {
    for (int j = 1; j &lt;=n ; j++) {
        sum+=i;//执行n^2次
    }
  }
  System.out.println(&quot;sum=&quot;+sum);
}</code></pre>
<p>如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为n时，以上算法执行的次数分别为：</p>
<p> 算法一：3次</p>
<p> 算法二：n+3次</p>
<p> 算法三：n^2+2次</p>
<p>如果用大O记法表示上述每个算法的时间复杂度，应该如何表示呢？基于我们对函数渐近增长的分析，推导大O阶的表示法有以下几个规则可以使用：</p>
<ol>
<li><p><strong>用常数1取代运行时间中的所有加法常数；</strong></p>
</li>
<li><p><strong>在修改后的运行次数中，只保留高阶项；</strong></p>
</li>
<li><p><strong>如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；</strong></p>
</li>
</ol>
<p>所以，上述算法的大O记法分别为：</p>
<p>算法一：O(1)</p>
<p>算法二：O(n)</p>
<p>算法三：O(n^2)</p>
<h5 id="1-1-2-2常见的大O阶"><a href="#1-1-2-2常见的大O阶" class="headerlink" title="1.1.2.2常见的大O阶"></a>1.1.2.2常见的大O阶</h5><p><strong>1.线性阶</strong></p>
<p>一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：</p>
<pre><code class="java">public static void main(String[] args) {
  int sum = 0;
  int n=100;
  for (int i = 1; i &lt;= n; i++) {
      sum += i;
  }
  System.out.println(&quot;sum=&quot; + sum);
}</code></pre>
<p>上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次</p>
<p><strong>2.平方阶</strong></p>
<p>一般嵌套循环属于这种时间复杂度</p>
<pre><code class="java">public static void main(String[] args) {
  int sum=0,n=100;
  for (int i = 1; i &lt;=n ; i++) {
    for (int j = 1; j &lt;=n ; j++) {
        sum+=i;
    }
  }
  System.out.println(sum);
}</code></pre>
<p>上面这段代码，n=100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环中出来，就需要执行100*100次，也就是n的平方次，所以这段代码的时间复杂度是O(n^2).</p>
<p><strong>3.立方阶</strong></p>
<p>一般三层嵌套循环属于这种时间复杂度</p>
<pre><code class="java">public static void main(String[] args) {
  int x=0,n=100;
  for (int i = 1; i &lt;=n ; i++) {
    for (int j = i; j &lt;=n ; j++) {
      for (int j = i; j &lt;=n ; j++) {
          x++;
      }
    }
  }
  System.out.println(x);
}</code></pre>
<p>上面这段代码，n=100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所以这段代码的时间复杂度是O(n^3).</p>
<p><strong>4.对数阶</strong></p>
<p>对数，属于高中数学的内容，我们分析程序以程序为主，数学为辅，所以不用过分担心。</p>
<pre><code class="java">int i=1,n=100;
while(i&lt;n){
    i = i*2;
}</code></pre>
<p>由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n,所以这个循环的时间复杂度为O(logn);</p>
<p>对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302116145.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302116636.png" alt></p>
<p><strong>5.常数阶</strong> </p>
<p>一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：</p>
<pre><code class="java">public static void main(String[] args) {
  int n=100;
  int i=n+2;
  System.out.println(i);
}</code></pre>
<p>上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度为O(1)</p>
<p>下面是对常见时间复杂度的一个总结：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302122161.png" alt></p>
<p>他们的复杂程度从低到高依次为：</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)</p>
<p>根据前面的折线图分析，我们会发现，从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。</p>
<h5 id="1-1-2-3-函数调用的时间复杂度分析"><a href="#1-1-2-3-函数调用的时间复杂度分析" class="headerlink" title="1.1.2.3 函数调用的时间复杂度分析"></a>1.1.2.3 函数调用的时间复杂度分析</h5><p>之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中时间复杂度。</p>
<p><strong>案例一</strong>：</p>
<pre><code class="java">public static void main(String[] args) {
  int n=100;
  for (int i = 0; i &lt; n; i++) {
      show(i);
  }
}
private static void show(int i) {
  System.out.println(i);
}</code></pre>
<p>在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部只执行了一行代码，所以show方法的时间复杂度为O(1),那main方法的时间复杂度就是O(n)</p>
<p><strong>案例二</strong>：</p>
<pre><code class="java">public static void main(String[] args) {
  int n=100;
  for (int i = 0; i &lt; n; i++) {
      show(i);
  }
}
private static void show(int i) {
  for (int j = 0; j &lt; i; i++) {
    System.out.println(i);
  }
}</code></pre>
<p>在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法的时间复杂度为O(n),那main方法的时间复杂度为O(n^2)</p>
<p><strong>案例三</strong>：</p>
<pre><code class="java">public static void main(String[] args) {
  int n=100;
  show(n);
  for (int i = 0; i &lt; n; i++) {
      show(i);
  }
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
        System.out.println(j);
    }
  }
}
private static void show(int i) {
  for (int j = 0; j &lt; i; i++) {
      System.out.println(i);
  }
}</code></pre>
<p>在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2, 第二个嵌套for循环内只执行了一行代码，所以其执行次数为n^2,那么main方法总执行次数为n+n^2+n^2=2n^2+n 。根据大O推导规则，去掉n保留最高阶项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2)</p>
<h5 id="1-1-2-4-最坏情况"><a href="#1-1-2-4-最坏情况" class="headerlink" title="1.1.2.4 最坏情况"></a>1.1.2.4 最坏情况</h5><p>从心理学角度讲，每个人对发生的事情都会有一个预期，比如看到半杯水，有人会说：哇哦，还有半杯水哦！但也有人会说：天哪，只有半杯水了。一般人处于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算，这样即使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果。假如最糟糕的结果并没有出现，当事人会很快乐。</p>
<p>算法分析也是类似，假如有一个需求：</p>
<p>有一个存储了n个随机数字的数组，请从中查找出指定的数字。</p>
<pre><code class="java">public int search(int num){
  int[] arr={11,10,8,9,7,22,23,0};
  for (int i = 0; i &lt; arr.length; i++) {
      if (num==arr[i]){
          return i;
      }
  }
  return -1;
}</code></pre>
<p><strong>最好情况</strong>：</p>
<p>查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)</p>
<p><strong>最坏情况</strong>：</p>
<p>查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)</p>
<p><strong>平均情况</strong>：</p>
<p>任何数字查找的平均成本是O(n/2)</p>
<p>最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。</p>
<hr>
<h3 id="1-2-算法的空间复杂度分析"><a href="#1-2-算法的空间复杂度分析" class="headerlink" title="1.2 算法的空间复杂度分析"></a>1.2 算法的空间复杂度分析</h3><p>计算机的软硬件都经历了一个比较漫长的演变史，作为为运算提供环境的内存，更是如此，从早些时候的512k,经历了1M，2M，4M…等，发展到现在的8G，甚至16G和32G，所以早期，算法在运行过程中对内存的占用情况也是一个经常需要考虑的问题。我么可以用算法的空间复杂度来描述算法对内存的占用。</p>
<h4 id="1-2-1java中常见内存占用"><a href="#1-2-1java中常见内存占用" class="headerlink" title="1.2.1java中常见内存占用"></a>1.2.1java中常见内存占用</h4><ol>
<li>基本数据类型内存占用情况：</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存占用字节数</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
</tbody></table>
<ol start="2">
<li>计算机访问内存的方式都是一次一个字节</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302132402.png" alt></p>
<ol start="3">
<li>一个引用（机器地址）需要8个字节表示：</li>
</ol>
<p>​    例如： Date date = new Date(),则date这个变量需要占用8个字节来表示</p>
<ol start="4">
<li>创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也</li>
</ol>
<p>​    有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。</p>
<ol start="5">
<li>一般内存的使用，如果不够8个字节，都会被自动填充为8字节：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202204302132047.png" alt></p>
<ol start="6">
<li>java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要</li>
</ol>
<p>​    24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。</p>
<h4 id="1-2-2-算法的空间复杂度"><a href="#1-2-2-算法的空间复杂度" class="headerlink" title="1.2.2 算法的空间复杂度"></a>1.2.2 算法的空间复杂度</h4><p>了解了java的内存最基本的机制，就能够有效帮助我们估计大量程序的内存使用情况。</p>
<p>算法的空间复杂度计算公式记作：S(n)=O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。</p>
<p><strong>案例</strong>： </p>
<p>对指定的数组元素进行反转，并返回反转的内容。</p>
<p>解法一：</p>
<pre><code class="java">public static int[] reverse1(int[] arr){
  int n=arr.length;//申请4个字节
  int temp;//申请4个字节
  for(int start=0,end=n-1;start&lt;=end;start++,end--){
    temp=arr[start];
    arr[start]=arr[end];
    arr[end]=temp;
  }
  return arr;
}</code></pre>
<p>解法二：</p>
<pre><code class="java">public static int[] reverse2(int[] arr){
  int n=arr.length;//申请4个字节
  int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节
  for (int i = n-1; i &gt;=0; i--) {
      temp[n-1-i]=arr[i];
  }
  return temp;
}</code></pre>
<p>忽略判断条件占用的内存，我们得出的内存占用情况如下：</p>
<p>算法一：</p>
<p>不管传入的数组大小为多少，始终额外申请4+4=8个字节；</p>
<p>算法二：</p>
<p>4+4n+24=4n+28;</p>
<p>根据大O推导法则，算法一的空间复杂度为O(1),算法二的空间复杂度为O(n),所以从空间占用的角度讲，算法一要优于算法二。</p>
<p>由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。</p>
<p>由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。</p>
<p>但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几kb，这个时候对算法的空间复杂度就有要求了，但是一般做java开发的，基本上都是服务器开发，一般不存在这样的问题。</p>
<hr>
<hr>
<h2 id="三、排序"><a href="#三、排序" class="headerlink" title="三、排序"></a>三、排序</h2><h3 id="一、简单排序"><a href="#一、简单排序" class="headerlink" title="一、简单排序"></a>一、简单排序</h3><p>在我们的程序中，排序是非常常见的一种需求，提供一些数据元素，把这些数据元素按照一定的规则进行排序。比如查询一些订单，按照订单的日期进行排序；再比如查询一些商品，按照商品的价格进行排序等等。所以，接下来我们要学习一些常见的排序算法。</p>
<p>在java的开发工具包jdk中，已经给我们提供了很多数据结构与算法的实现，比如List，Set，Map，Math等等，都是以API的方式提供，这种方式的好处在于一次编写，多处使用。我们借鉴jdk的方式，也把算法封装到某个类中，那如果是这样，在我们写java代码之前，就需要先进行API的设计，设计好之后，再对这些API进行实现。</p>
<p>就比如我们先设计一套API如下：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>ArrayList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>ArrayList()：创建ArrayList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.boolean add(E e)：向集合中添加元素<br>2.E remove(int index):从集合中删除指定的元素</td>
</tr>
</tbody></table>
<p>然后再使用java代码去实现它。以后我们讲任何数据结构与算法都是以这种方式讲解</p>
<h4 id="1-1-Comparable接口介绍"><a href="#1-1-Comparable接口介绍" class="headerlink" title="1.1 Comparable接口介绍"></a>1.1 Comparable接口介绍</h4><p>由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序规则的，在这里我们以案例的形式对Comparable接口做一个简单的回顾。</p>
<p><strong>需求</strong>： </p>
<ol>
<li><p>定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；</p>
</li>
<li><p>定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试</p>
</li>
</ol>
<pre><code class="java">//学生类
public class Student implements Comparable&lt;Student&gt;{

  private String username;
  private int age;

  public String getUsername() {
      return username;
    }

  public void setUsername(String username) {
    this.username = username;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  @Override
  public String toString() {
    return &quot;Student{&quot; +
            &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +
            &quot;, age=&quot; + age +
            &#39;}&#39;;
  }
  //定义比较规则
  @Override
  public int compareTo(Student o) {
      return this.getAge()-o.getAge();
  }
}

//测试类
public class Test {
  public static void main(String[] args) {

    Student stu1 = new Student();
    stu1.setUsername(&quot;zhangsan&quot;);
    stu1.setAge(17);

    Student stu2 = new Student();
    stu2.setUsername(&quot;lisi&quot;);
    stu2.setAge(19);

    Comparable max = getMax(stu1, stu2);
    System.out.println(max);
    }

  //测试方法，获取两个元素中的较大值
  public static Comparable getMax(Comparable c1,Comparable c2){
      int cmp = c1.compareTo(c2);
      if (cmp&gt;=0){
          return c1;
      }else{
          return c2;
      }
  }
}</code></pre>
<hr>
<h4 id="1-2-冒泡排序"><a href="#1-2-冒泡排序" class="headerlink" title="1.2 冒泡排序"></a>1.2 冒泡排序</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
<h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a><strong>需求</strong>：</h5><p>排序前：{4,5,6,3,2,1}</p>
<p>排序后：{1,2,3,4,5,6}</p>
<h5 id="排序原理："><a href="#排序原理：" class="headerlink" title="排序原理："></a><strong>排序原理</strong>：</h5><ol>
<li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011349842.png" alt></p>
<h5 id="冒泡排序API设计："><a href="#冒泡排序API设计：" class="headerlink" title="冒泡排序API设计："></a><strong>冒泡排序API设计</strong>：</h5><table>
<thead>
<tr>
<th>类名</th>
<th>Bubble</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Bubble()：创建Bubble对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="冒泡排序的代码实现："><a href="#冒泡排序的代码实现：" class="headerlink" title="冒泡排序的代码实现："></a><strong>冒泡排序的代码实现</strong>：</h5><pre><code class="java">//排序代码
public class Bubble {
  /*
      对数组a中的元素进行排序
  */
  public static void sort(Comparable[] a){
    for(int i=a.length-1;i&gt;0;i--){
          for (int j = 0; j &lt;i; j++) {
              if (greater(a[j],a[j+1])){
                  exch(a,j,j+1);
              }
            }
        }
    }

  /*
      比较v元素是否大于w元素
  */
  private static boolean greater(Comparable v,Comparable w){
      return v.compareTo(w)&gt;0;
  }

  /*
      数组元素i和j交换位置
  */
  private static void exch(Comparable[] a,int i,int j){
      Comparable t = a[i];
      a[i]=a[j];
      a[j]=t;
  }
}

//测试代码
public class Test {
    public static void main(String[] args) {
        Integer[] a = {4, 5, 6, 3, 2, 1};
        Bubble.sort(a);
        System.out.println(Arrays.toString(a));
    }
}</code></pre>
<h5 id="冒泡排序的时间复杂度分析："><a href="#冒泡排序的时间复杂度分析：" class="headerlink" title="冒泡排序的时间复杂度分析："></a><strong>冒泡排序的时间复杂度分析：</strong></h5><p>冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p>
<p>在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么：</p>
<p>元素比较的次数为：</p>
<p>​    (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;        </p>
<p>元素交换的次数为：</p>
<p>​    (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>总执行次数为：</p>
<p>​    (N^2/2-N/2)+(N^2/2-N/2)=N^2-N;</p>
<p>按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2).</p>
<hr>
<h4 id="1-3-选择排序"><a href="#1-3-选择排序" class="headerlink" title="1.3 选择排序"></a>1.3 选择排序</h4><p>选择排序是一种更加简单直观的排序方法。</p>
<h5 id="需求：-1"><a href="#需求：-1" class="headerlink" title="需求："></a><strong>需求</strong>：</h5><p>排序前：{4,6,8,7,9,2,10,1}</p>
<p>排序后：{1,2,4,5,7,8,9,10}</p>
<h5 id="排序原理：-1"><a href="#排序原理：-1" class="headerlink" title="排序原理："></a><strong>排序原理</strong>：</h5><p>1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>
<p>2.交换第一个索引处和最小值所在的索引处的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011355111.png" alt></p>
<h5 id="选择排序API设计："><a href="#选择排序API设计：" class="headerlink" title="选择排序API设计："></a><strong>选择排序API设计</strong>：</h5><table>
<thead>
<tr>
<th>类名</th>
<th>Selection</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Selection()：创建Selection对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="选择排序的代码实现："><a href="#选择排序的代码实现：" class="headerlink" title="选择排序的代码实现："></a><strong>选择排序的代码实现：</strong></h5><pre><code class="java">//排序代码
public class Selection {
  /*
      对数组a中的元素进行排序
  */
  public static void sort(Comparable[] a){
    for (int i=0;i&lt;=a.length-2;i++){
        //假定本次遍历，最小值所在的索引是i
        int minIndex=i;
        for (int j=i+1;j&lt;a.length;j++){
            if (greater(a[minIndex],a[j])){
                //跟换最小值所在的索引
                minIndex=j;
            }
        }
      //交换i索引处和minIndex索引处的值
      exch(a,i,minIndex);
        }
    }

  /*
  比较v元素是否大于w元素
  */
  private static boolean greater(Comparable v,Comparable w){
      return v.compareTo(w)&gt;0;
  }

  /*
  数组元素i和j交换位置
  */
  private static void exch(Comparable[] a,int i,int j){
      Comparable t = a[i];
      a[i]=a[j];
      a[j]=t;
  }
}

//测试代码
public class Test {
    public static void main(String[] args) {
        Integer[] a = {4,6,8,7,9,2,10,1};
        Selection.sort(a);
        System.out.println(Arrays.toString(a));
    }
}</code></pre>
<h5 id="选择排序的时间复杂度分析："><a href="#选择排序的时间复杂度分析：" class="headerlink" title="选择排序的时间复杂度分析："></a><strong>选择排序的时间复杂度分析：</strong></h5><p>选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据</p>
<p>交换次数和数据比较次数：</p>
<p>数据比较次数：</p>
<p>​    (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>数据交换次数：</p>
<p>​    N-1</p>
<p>时间复杂度：N^2/2-N/2+（N-1）=N^2/2+N/2-1;</p>
<p>根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);</p>
<hr>
<h4 id="1-4-插入排序"><a href="#1-4-插入排序" class="headerlink" title="1.4 插入排序"></a>1.4 插入排序</h4><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。</p>
<p>插入排序的工作方式非常像人们排序一手扑克牌一样。开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011400693.png" alt></p>
<h5 id="需求：-2"><a href="#需求：-2" class="headerlink" title="需求："></a><strong>需求：</strong></h5><p>排序前：{4,3,2,10,12,1,5,6}</p>
<p>排序后：{1,2,3,4,5,6,10,12}</p>
<h5 id="排序原理：-2"><a href="#排序原理：-2" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><ol>
<li><p>把所有的元素分为两组，已经排序的和未排序的；</p>
</li>
<li><p>找到未排序的组中的第一个元素，向已经排序的组中进行插入；</p>
</li>
<li><p>倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011401687.png" alt></p>
<h5 id="插入排序API设计："><a href="#插入排序API设计：" class="headerlink" title="插入排序API设计："></a><strong>插入排序API设计：</strong></h5><table>
<thead>
<tr>
<th>类名</th>
<th>Insertion</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Insertion()：创建Insertion对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="插入排序代码实现："><a href="#插入排序代码实现：" class="headerlink" title="插入排序代码实现："></a><strong>插入排序代码实现：</strong></h5><pre><code class="java">public class Insertion {
  /*
      对数组a中的元素进行排序
  */
    public static void sort(Comparable[] a){
        for (int i=1;i&lt;a.length;i++){
            //当前元素为a[i],依次和i前面的元素比较，找到一个小于等于a[i]的元素
            for (int j=i;j&gt;0;j--){
                if (greater(a[j-1],a[j])){
                    //交换元素
                    exch(a,j-1,j);
                }else {
                    //找到了该元素，结束
                    break;
                }
            }
      }
    }

  /*
      比较v元素是否大于w元素
  */
  private static boolean greater(Comparable v,Comparable w){
      return v.compareTo(w)&gt;0;
  }

  /*
      数组元素i和j交换位置
  */
  private static void exch(Comparable[] a,int i,int j){
    Comparable t = a[i];
    a[i]=a[j];
    a[j]=t;
  }
}</code></pre>
<h5 id="插入排序的时间复杂度分析"><a href="#插入排序的时间复杂度分析" class="headerlink" title="插入排序的时间复杂度分析"></a><strong>插入排序的时间复杂度分析</strong></h5><p>插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p>
<p>最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么：</p>
<p>比较的次数为：</p>
<p>​    (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>交换的次数为：</p>
<p>​    (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>总执行次数为：</p>
<p>​    (N^2/2-N/2)+(N^2/2-N/2)=N^2-N;</p>
<p>按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2).</p>
<hr>
<hr>
<h3 id="二、高级排序"><a href="#二、高级排序" class="headerlink" title="二、高级排序"></a>二、高级排序</h3><p>之前我们学习过基础排序，包括冒泡排序，选择排序还有插入排序，并且对他们在最坏情况下的时间复杂度做了分析，发现都是O(N^2)，而平方阶通过我们之前学习算法分析我们知道，随着输入规模的增大，时间成本将急剧上升，所以这些基本排序方法不能处理更大规模的问题，接下来我们学习一些高级的排序算法，争取降低算法的时间复杂度最高阶次幂。</p>
<h4 id="2-1希尔排序"><a href="#2-1希尔排序" class="headerlink" title="2.1希尔排序"></a>2.1希尔排序</h4><p>希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。</p>
<p>前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数，这样的需求如何实现呢？接下来我们来看看希尔排序的原理。</p>
<h5 id="需求：-3"><a href="#需求：-3" class="headerlink" title="需求："></a><strong>需求：</strong></h5><p>​    排序前：{9,1,2,5,7,4,8,6,3,5}</p>
<p>​    排序后：{1,2,3,4,5,5,6,7,8,9}</p>
<h5 id="排序原理：-3"><a href="#排序原理：-3" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><ol>
<li><p>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；</p>
</li>
<li><p>对分好组的每一组数据完成插入排序；</p>
</li>
<li><p>减小增长量，最小减为1，重复第二步操作。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011407433.png" alt></p>
<p>增长量h的确定：增长量h的值每一固定的规则，我们这里采用以下规则：</p>
<pre><code class="java">int h=1
while(h&lt;5){
    h=2h+1；//3,7
}
//循环结束后我们就可以确定h的最大值；
h的减小规则为：
    h=h/2</code></pre>
<h5 id="希尔排序的API设计："><a href="#希尔排序的API设计：" class="headerlink" title="希尔排序的API设计："></a><strong>希尔排序的API设计：</strong></h5><table>
<thead>
<tr>
<th>类名</th>
<th>Shell</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Shell()：创建Shell对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="希尔排序的代码实现："><a href="#希尔排序的代码实现：" class="headerlink" title="希尔排序的代码实现："></a><strong>希尔排序的代码实现：</strong></h5><pre><code class="java">//排序代码
public class Shell {
  /*
      对数组a中的元素进行排序
  */
    public static void sort(Comparable[] a){
    int N = a.length;
    //确定增长量h的最大值
    int h=1;
    while(h&lt;N/2){
        h=h*2+1;
    }

    //当增长量h小于1，排序结束
    while(h&gt;=1){
        //找到待插入的元素
        for (int i=h;i&lt;N;i++){
            //a[i]就是待插入的元素
                //把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中
                for (int j=i;j&gt;=h;j-=h){
                    //a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么交换位置，如果不小于，a[j]大，则插入完成。
                    if (greater(a[j-h],a[j])){
                        exch(a,j,j-h);
                    }else{
                        break;
                    }
                }
            }
          h/=2;
        }
    }

  /*
      比较v元素是否大于w元素
  */
  private static boolean greater(Comparable v,Comparable w){
      return v.compareTo(w)&gt;0;
  }

  /*
      数组元素i和j交换位置
  */
  private static void exch(Comparable[] a,int i,int j){
    Comparable t = a[i];
    a[i]=a[j];
    a[j]=t;
  }
}

//测试代码
public class Test {
  public static void main(String[] args) {
    Integer[] a = {9,1,2,5,7,4,8,6,3,5} ;
    Shell.sort(a);
    System.out.println(Arrays.toString(a));
  }
}</code></pre>
<h5 id="希尔排序的时间复杂度分析"><a href="#希尔排序的时间复杂度分析" class="headerlink" title="希尔排序的时间复杂度分析"></a><strong>希尔排序的时间复杂度分析</strong></h5><p>在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。</p>
<p>我们可以使用事后分析法对希尔排序和插入排序做性能比较。</p>
<p>在资料的测试数据文件夹下有一个reverse_shell_insertion.txt文件，里面存放的是从100000到1的逆向数据，我们可以根据这个批量数据完成测试。测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时间差就是排序的耗时。</p>
<p>希尔排序和插入排序性能比较测试代码：</p>
<pre><code class="java">public class SortCompare {
  public static void main(String[] args) throws Exception{
    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    //读取reverse_arr.txt文件
    BufferedReader reader = new BufferedReader(new InputStreamReader(new
    FileInputStream(&quot;reverse_shell_insertion.txt&quot;)));
    String line=null;
    while((line=reader.readLine())!=null){

      //把每一个数字存入到集合中
      list.add(Integer.valueOf(line));
    }
    reader.close();
    //把集合转换成数组
    Integer[] arr = new Integer[list.size()];
    list.toArray(arr);

    testInsertion(arr);//使用插入排序耗时：20859
    // testShell(arr);//使用希尔排序耗时：31

  }
  public static void testInsertion(Integer[] arr){
    //使用插入排序完成测试
    long start = System.currentTimeMillis();
    Insertion.sort(arr);
    long end= System.currentTimeMillis();
    System.out.println(&quot;使用插入排序耗时：&quot;+(end-start));
  }

  public static void testShell(Integer[] arr){
    //使用希尔排序完成测试
    long start = System.currentTimeMillis();
    Shell.sort(arr);
    long end = System.currentTimeMillis();
    System.out.println(&quot;使用希尔排序耗时：&quot;+(end-start));
  }
}</code></pre>
<p>通过测试发现，在处理大批量数据时，希尔排序的性能确实高于插入排序。</p>
<hr>
<h4 id="2-2-归并排序"><a href="#2-2-归并排序" class="headerlink" title="2.2 归并排序"></a>2.2 归并排序</h4><h5 id="2-2-1-递归"><a href="#2-2-1-递归" class="headerlink" title="2.2.1 递归"></a>2.2.1 递归</h5><p>正式学习归并排序之前，我们得先学习一下递归算法。</p>
<h6 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h6><p>定义方法时，在方法内部调用方法本身，称之为递归.</p>
<pre><code class="java">public void show(){
  System.out.println(&quot;aaaa&quot;);
  show();
}</code></pre>
<h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h6><p>它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的</p>
<p>程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p>
<h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h6><p>在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011419889.png" alt></p>
<h6 id="需求：-4"><a href="#需求：-4" class="headerlink" title="需求："></a><strong>需求：</strong></h6><p>请定义一个方法，使用递归完成求N的阶乘；</p>
<pre><code class="java">分析：
1!:     1
2!:     2*1=2*1!
3!:     3*2*1=3*2!
4!:     4*3*2*1=4*3!
...
n!: n*(n-1)*(n-2)...*2*1=n*(n-1)!
所以，假设有一个方法factorial(n)用来求n的阶乘，那么n的阶乘还可以表示为n*factorial(n-1)</code></pre>
<h6 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a><strong>代码实现：</strong></h6><pre><code class="java">public class Test {
  public static void main(String[] args) throws Exception {
    int result = factorial(5);
    System.out.println(result);
  }

  public static int factorial(int n){
    if (n==1){
        return 1;
      }
    return n*factorial(n-1);
  }
}</code></pre>
<hr>
<h5 id="2-2-2-归并排序"><a href="#2-2-2-归并排序" class="headerlink" title="2.2.2 归并排序"></a>2.2.2 归并排序</h5><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h6 id="需求：-5"><a href="#需求：-5" class="headerlink" title="需求："></a><strong>需求：</strong></h6><p>排序前：{8,4,5,7,1,3,6,2}</p>
<p>排序后：{1,2,3,4,5,6,7,8}</p>
<h6 id="排序原理：-4"><a href="#排序原理：-4" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h6><ol>
<li><p>尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</p>
</li>
<li><p>将相邻的两个子组进行合并成一个有序的大组；</p>
</li>
<li><p>不断的重复步骤2，直到最终只有一个组为止。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011423913.png" alt></p>
<h6 id="归并排序API设计："><a href="#归并排序API设计：" class="headerlink" title="归并排序API设计："></a><strong>归并排序API设计：</strong></h6><table>
<thead>
<tr>
<th>类名</th>
<th>Merge</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Merge()：创建Merge对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br>2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br>3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到所以mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从索引lo到索引hi）<br>4.private static boolean less(Comparable v,Comparable w):判断v是否小于w<br>5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private static Comparable[] assist：完成归并操作需要的辅助数组</td>
</tr>
</tbody></table>
<h6 id="归并原理："><a href="#归并原理：" class="headerlink" title="归并原理："></a><strong>归并原理：</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011836639.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011836698.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011837593.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011837045.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011837947.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011838934.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011839139.png" alt></p>
<h6 id="归并排序代码实现："><a href="#归并排序代码实现：" class="headerlink" title="归并排序代码实现："></a><strong>归并排序代码实现：</strong></h6><pre><code class="java">//排序代码
public class Merge {
    private static Comparable[] assist;//归并所需要的辅助数组

  /*
      对数组a中的元素进行排序
  */
  public static void sort(Comparable[] a) {
    assist = new Comparable[a.length];
    int lo = 0;
    int hi = a.length-1;
    sort(a, lo, hi);
  }

  /*
      对数组a中从lo到hi的元素进行排序
  */
  private static void sort(Comparable[] a, int lo, int hi) {
      if (hi &lt;= lo) {
          return;
      }

        int mid = lo + (hi - lo) / 2;

        //对lo到mid之间的元素进行排序；
        sort(a, lo, mid);
        //对mid+1到hi之间的元素进行排序；
        sort(a, mid+1, hi);
    //对lo到mid这组数据和mid到hi这组数据进行归并
    merge(a, lo, mid, hi);
    }

  /*
      对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并
  */
  private static void merge(Comparable[] a, int lo, int mid, int hi) {
    //lo到mid这组数据和mid+1到hi这组数据归并到辅助数组assist对应的索引处
    int i = lo;//定义一个指针，指向assist数组中开始填充数据的索引
    int p1 = lo;//定义一个指针，指向第一组数据的第一个元素

    int p2 = mid + 1;//定义一个指针，指向第二组数据的第一个元素
    //比较左边小组和右边小组中的元素大小，哪个小，就把哪个数据填充到assist数组中
    while (p1 &lt;= mid &amp;&amp; p2 &lt;= hi) {
      if (less(a[p1], a[p2])) {
          assist[i++] = a[p1++];
      } else {
          assist[i++] = a[p2++];
          }
        }

    //上面的循环结束后，如果退出循环的条件是p1&lt;=mid，则证明左边小组中的数据已经归并完毕，如果退出循环的条件是p2&lt;=hi,则证明右边小组的数据已经填充完毕；
    //所以需要把未填充完毕的数据继续填充到assist中,//下面两个循环，只会执行其中的一个
    while(p1&lt;=mid){
        assist[i++]=a[p1++];
    }
    while(p2&lt;=hi){
        assist[i++]=a[p2++];
    }

        //到现在为止，assist数组中，从lo到hi的元素是有序的，再把数据拷贝到a数组中对应的索引处
    for (int index=lo;index&lt;=hi;index++){
        a[index]=assist[index];
    }
    }


  /*
      比较v元素是否小于w元素
  */
  private static boolean less(Comparable v, Comparable w) {
      return v.compareTo(w) &lt; 0;
  }

  /*
      数组元素i和j交换位置
  */
  private static void exch(Comparable[] a, int i, int j) {
    Comparable t = a[i];
    a[i] = a[j];
    a[j] = t;
  }
}

//测试代码
public class Test {
  public static void main(String[] args) throws Exception {
    Integer[] arr = {8, 4, 5, 7, 1, 3, 6, 2};
    Merge.sort(arr);
    System.out.println(Arrays.toString(arr));
  }
}</code></pre>
<h6 id="归并排序时间复杂度分析："><a href="#归并排序时间复杂度分析：" class="headerlink" title="归并排序时间复杂度分析："></a><strong>归并排序时间复杂度分析：</strong></h6><p>归并排序是分治思想的最典型的例子，上面的算法中，对a[lo…hi]进行排序，先将它分为a[lo…mid]和a[mid+1…hi]两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011848460.png" alt></p>
<p>用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆log8次，值为3，所以树共有3层,那么自顶向下第k层有2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较。因此每层的比较次数为 2^k * 2^(3-k)=2^3,那么3层总共为 3*2^3。</p>
<p>假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面3*2^3中</p>
<p>的3这个层数，最终得出的归并排序的时间复杂度为：log2(n)* 2^(log2(n))=log2(n)*n,根据大O推导法则，忽略底数，最终归并排序的时间复杂度为O(nlogn);</p>
<h6 id="归并排序的缺点："><a href="#归并排序的缺点：" class="headerlink" title="归并排序的缺点："></a><strong>归并排序的缺点：</strong></h6><p>需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。</p>
<h6 id="归并排序与希尔排序性能测试："><a href="#归并排序与希尔排序性能测试：" class="headerlink" title="归并排序与希尔排序性能测试："></a><strong>归并排序与希尔排序性能测试：</strong></h6><p>之前我们通过测试可以知道希尔排序的性能是由于插入排序的，那现在学习了归并排序后，归并排序的效率与希尔排序的效率哪个高呢？我们使用同样的测试方式来完成一样这两个排序算法之间的性能比较。</p>
<p>在资料的测试数据文件夹下有一个reverse_arr.txt文件，里面存放的是从1000000到1的逆向数据，我们可以根据这个批量数据完成测试。测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时间差就是排序的耗时。</p>
<h6 id="希尔排序和插入排序性能比较测试代码："><a href="#希尔排序和插入排序性能比较测试代码：" class="headerlink" title="希尔排序和插入排序性能比较测试代码："></a><strong>希尔排序和插入排序性能比较测试代码：</strong></h6><pre><code class="java">public class SortCompare {
    public static void main(String[] args) throws Exception{
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        //读取a.txt文件
        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;reverse_merge_shell.txt&quot;)));
        String line=null;
    while((line=reader.readLine())!=null){
        //把每一个数字存入到集合中
        list.add(Integer.valueOf(line));
    }
    reader.close();
    //把集合转换成数组
    Integer[] arr = new Integer[list.size()];
    list.toArray(arr);

    // testMerge(arr);//使用归并排序耗时：1200
    testShell(arr);//使用希尔排序耗时：1277

    }
  public static void testMerge(Integer[] arr){
    //使用插入排序完成测试
    long start = System.currentTimeMillis();
    Merge.sort(arr);
    long end= System.currentTimeMillis();
    System.out.println(&quot;使用归并排序耗时：&quot;+(end-start));
  }

  public static void testShell(Integer[] arr){
    //使用希尔排序完成测试
    long start = System.currentTimeMillis();
    Shell.sort(arr);
    long end = System.currentTimeMillis();
    System.out.println(&quot;使用希尔排序耗时：&quot;+(end-start));
  }
}                                                            </code></pre>
<p>通过测试，发现希尔排序和归并排序在处理大批量数据时差别不是很大。</p>
<hr>
<h4 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h4><p>快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h5 id="需求：-6"><a href="#需求：-6" class="headerlink" title="需求："></a><strong>需求：</strong></h5><p>排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}</p>
<p>排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9}</p>
<h5 id="排序原理：-5"><a href="#排序原理：-5" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><ol>
<li><p>首先设定一个分界值，通过该分界值将数组分成左右两部分；</p>
</li>
<li><p>将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；</p>
</li>
<li><p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
</li>
<li><p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011854910.png" alt></p>
<h5 id="快速排序API设计"><a href="#快速排序API设计" class="headerlink" title="快速排序API设计:"></a><strong>快速排序API设计:</strong></h5><table>
<thead>
<tr>
<th>类名</th>
<th>Quick</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Quick()：创建Quick对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br>2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br>3.public static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引<br>4.private static boolean less(Comparable v,Comparable w):判断v是否小于w<br>5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>切分原理：</strong> </p>
<p>把一个数组切分成两个子数组的基本思想：</p>
<ol>
<li><p>找一个基准值，用两个指针分别指向数组的头部和尾部；</p>
</li>
<li><p>先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；</p>
</li>
<li><p>再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；</p>
</li>
<li><p>交换当前左边指针位置和右边指针位置的元素；</p>
</li>
<li><p>重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011857764.png" alt></p>
<p>![image-20220501185836765](/Users/shixiang/Library/Application Support/typora-user-images/image-20220501185836765.png)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205011859072.png" alt></p>
<h5 id="快速排序代码实现："><a href="#快速排序代码实现：" class="headerlink" title="快速排序代码实现："></a><strong>快速排序代码实现：</strong></h5><pre><code class="java">//排序代码
public class Quick {
  public static void sort(Comparable[] a) {
    int lo = 0;
    int hi = a.length - 1;
    sort(a, lo,hi);
  }

  private static void sort(Comparable[] a, int lo, int hi) {
    if (hi&lt;=lo){
        return;
    }
    //对a数组中，从lo到hi的元素进行切分
    int partition = partition(a, lo, hi);
    //对左边分组中的元素进行排序

    //对右边分组中的元素进行排序
    sort(a,lo,partition-1);
    sort(a,partition+1,hi);
    }

  public static int partition(Comparable[] a, int lo, int hi) {
    Comparable key=a[lo];//把最左边的元素当做基准值
    int left=lo;//定义一个左侧指针，初始指向最左边的元素
    int right=hi+1;//定义一个右侧指针，初始指向左右侧的元素下一个位置
    //进行切分
    while(true){
      //先从右往左扫描，找到一个比基准值小的元素
      while(less(key,a[--right])){//循环停止，证明找到了一个比基准值小的元素
        if (right==lo){
        break;//已经扫描到最左边了，无需继续扫描
      }
    }

    //再从左往右扫描，找一个比基准值大的元素
    while(less(a[++left],key)){//循环停止，证明找到了一个比基准值大的元素
      if (left==hi){
          break;//已经扫描到了最右边了，无需继续扫描
      }
        }

    if (left&gt;=right){
        //扫描完了所有元素，结束循环
        break;
      }else{
        //交换left和right索引处的元素
        exch(a,left,right);
      }
        }

    //交换最后rigth索引处和基准值所在的索引处的值
    exch(a,lo,right);
    return right;//right就是切分的界限
    }

  /*
      数组元素i和j交换位置
  */
  private static void exch(Comparable[] a, int i, int j) {
    Comparable t = a[i];
    a[i] = a[j];
    a[j] = t;
  }

  /*
      比较v元素是否小于w元素
  */
  private static boolean less(Comparable v, Comparable w) {
      return v.compareTo(w) &lt; 0;
  }
}

//测试代码
public class Test {
  public static void main(String[] args) throws Exception {
    Integer[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 8};
    Quick.sort(arr);
    System.out.println(Arrays.toString(arr));
  }
}</code></pre>
<h5 id="快速排序和归并排序的区别："><a href="#快速排序和归并排序的区别：" class="headerlink" title="快速排序和归并排序的区别："></a><strong>快速排序和归并排序的区别：</strong></h5><p>快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</p>
<h5 id="快速排序时间复杂度分析："><a href="#快速排序时间复杂度分析：" class="headerlink" title="快速排序时间复杂度分析："></a><strong>快速排序时间复杂度分析：</strong></h5><p>快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个快速排序的时间复杂度和切分的次数相关。</p>
<p>最优情况：每一次切分选择的基准数字刚好将当前序列等分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012023726.png" alt></p>
<p>如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，最优情况下快速排序的时间复杂度为O(nlogn);</p>
<p>最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2);</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012024400.png" alt></p>
<p>平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对平均情况的时间复杂度做证明了。</p>
<hr>
<h4 id="2-4-排序的稳定性"><a href="#2-4-排序的稳定性" class="headerlink" title="2.4 排序的稳定性"></a>2.4 排序的稳定性</h4><h5 id="稳定性的定义："><a href="#稳定性的定义：" class="headerlink" title="稳定性的定义："></a><strong>稳定性的定义：</strong></h5><p>数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012025459.png" alt></p>
<h5 id="稳定性的意义："><a href="#稳定性的意义：" class="headerlink" title="稳定性的意义："></a><strong>稳定性的意义：</strong></h5><p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。</p>
<p>第一次按照价格从低到高排序：</p>
<table>
<thead>
<tr>
<th>商品名称</th>
<th>价格</th>
<th>销量</th>
</tr>
</thead>
<tbody><tr>
<td>三星Note9</td>
<td>3999</td>
<td>21</td>
</tr>
<tr>
<td>华为mate30</td>
<td>4999</td>
<td>65</td>
</tr>
<tr>
<td>华为p30</td>
<td>5999</td>
<td>65</td>
</tr>
<tr>
<td>Iphone 11</td>
<td>6899</td>
<td>32</td>
</tr>
</tbody></table>
<p>第二次按照销量进行从高到低排序：</p>
<table>
<thead>
<tr>
<th>商品名称</th>
<th>价格</th>
<th>销量</th>
</tr>
</thead>
<tbody><tr>
<td>三星Note9</td>
<td>4999</td>
<td>65</td>
</tr>
<tr>
<td>华为mate30</td>
<td>5999</td>
<td>65</td>
</tr>
<tr>
<td>华为p30</td>
<td>6899</td>
<td>32</td>
</tr>
<tr>
<td>Iphone 11</td>
<td>3999</td>
<td>21</td>
</tr>
</tbody></table>
<h5 id="常见排序算法的稳定性："><a href="#常见排序算法的稳定性：" class="headerlink" title="常见排序算法的稳定性："></a><strong>常见排序算法的稳定性：</strong></h5><p><strong>冒泡排序：</strong> </p>
<p>​    只有当arr[i]&gt;arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序算法。</p>
<p><strong>选择排序:</strong> </p>
<p>​    选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2，所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种不稳定的排序算法。</p>
<p><strong>插入排序：</strong> </p>
<p>​    比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p><strong>希尔排序：</strong> </p>
<p>​    希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。</p>
<p><strong>归并排序：</strong> </p>
<p>​    归并排序在归并的过程中，只有arr[i]&lt;arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的。</p>
<p><strong>快速排序：</strong> </p>
<p>​    快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法。</p>
<hr>
<hr>
<h2 id="四、线性表"><a href="#四、线性表" class="headerlink" title="四、线性表"></a>四、线性表</h2><p>线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012031203.png" alt></p>
<p><code>前驱元素</code>：</p>
<p>​    若A元素在B元素的前面，则称A为B的前驱元素</p>
<p><code>后继元素</code>：</p>
<p>​    若B元素在A元素的后面，则称B为A的后继元素</p>
<p> <strong>线性表的特征</strong>：</p>
<blockquote>
<p>数据元素之间具有一种“一对一”的逻辑关系。</p>
</blockquote>
<ol>
<li><p>第一个数据元素没有前驱，这个数据元素被称为头结点；</p>
</li>
<li><p>最后一个数据元素没有后继，这个数据元素被称为尾结点；</p>
</li>
<li><p>除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。</p>
</li>
</ol>
<p>如果把线性表用数学语言来定义，则可以表示为(a1,…ai-1,ai,ai+1,…an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai的后继元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012033085.png" alt></p>
<p><strong>线性表的分类</strong>：</p>
<p>线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为<code>顺序表</code>和<code>链表</code>。</p>
<hr>
<h3 id="1-1-顺序表"><a href="#1-1-顺序表" class="headerlink" title="1.1 顺序表"></a>1.1 顺序表</h3><p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012035787.png" alt></p>
<h4 id="1-1-1-顺序表的实现"><a href="#1-1-1-顺序表的实现" class="headerlink" title="1.1.1 顺序表的实现"></a>1.1.1 顺序表的实现</h4><h5 id="顺序表API设计："><a href="#顺序表API设计：" class="headerlink" title="顺序表API设计："></a>顺序表API设计：</h5><table>
<thead>
<tr>
<th>类名</th>
<th>SequenceList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置线性表<br>2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>6.public void insert(T t):向线性表中添加一个元素t<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] eles：存储元素的数组<br>2.private int N:当前线性表的长度</td>
</tr>
</tbody></table>
<h5 id="顺序表的代码实现："><a href="#顺序表的代码实现：" class="headerlink" title="顺序表的代码实现："></a>顺序表的代码实现：</h5><pre><code class="java">//顺序表代码
public class SequenceList&lt;T&gt; {
  //存储元素的数组
  private T[] eles;
  //记录当前顺序表中的元素个数
  private int N;

  //构造方法
  public SequenceList(int capacity){
    eles = (T[])new Object[capacity];
    N=0;
    }

  //将一个线性表置为空表
  public void clear(){
      N=0;
  }

  //判断当前线性表是否为空表
  public boolean isEmpty(){
    return N==0;
  }

  //获取线性表的长度
  public int length(){
      return N;
  }

  //获取指定位置的元素
  public T get(int i){
    if (i&lt;0 || i&gt;=N){
        throw new RuntimeException(&quot;当前元素不存在！&quot;);
    }
      return eles[i];
  }

  //向线型表中添加元素t
  public void insert(T t){
    if (N==eles.length){
        throw new RuntimeException(&quot;当前表已满&quot;);
    }
      eles[N++] = t;
  }

  //在i元素处插入元素t
  public void insert(int i,T t){
    if (i==eles.length){
        throw new RuntimeException(&quot;当前表已满&quot;);
    }

    if (i&lt;0 || i&gt;N){
        throw new RuntimeException(&quot;插入的位置不合法&quot;);
    }

    //把i位置空出来，i位置及其后面的元素依次向后移动一位
    for (int index=N;index&gt;i;index--){
        eles[index]=eles[index-1];
    }

    //把t放到i位置处
    eles[i]=t;
    //元素数量+1
    N++;
  }

  //删除指定位置i处的元素，并返回该元素
  public T remove(int i){
    if (i&lt;0 || i&gt;N-1){
        throw new RuntimeException(&quot;当前要删除的元素不存在&quot;);
    }
    //记录i位置处的元素
    T result = eles[i];

    //把i位置后面的元素都向前移动一位
    for (int index=i;index&lt;N-1;index++){
        eles[index]=eles[index+1];
    }

    //当前元素数量-1
    N--;
    return result;
  }
  //查找t元素第一次出现的位置
  public int indexOf(T t){
    if(t==null){
        throw new RuntimeException(&quot;查找的元素不合法&quot;);
    }

    for (int i = 0; i &lt; N; i++) {
      if (eles[i].equals(t)){
        return i;
      }
      }
      return -1;
  }
}

//测试代码
public class SequenceListTest {    

  public static void main(String[] args) {
    //创建顺序表对象
    SequenceList&lt;String&gt; sl = new SequenceList&lt;&gt;(10);

    //测试插入
    sl.insert(&quot;姚明&quot;);
    sl.insert(&quot;科比&quot;);
    sl.insert(&quot;麦迪&quot;);
    sl.insert(1,&quot;詹姆斯&quot;);
    //测试获取
    String getResult = sl.get(1);
    System.out.println(&quot;获取索引1处的结果为：&quot;+getResult);
    //测试删除
    String removeResult = sl.remove(0);
    System.out.println(&quot;删除的元素是：&quot;+removeResult);
    //测试清空
    sl.clear();
    System.out.println(&quot;清空后的线性表中的元素个数为:&quot;+sl.length());
  }
}</code></pre>
<h4 id="1-1-2-顺序表的遍历"><a href="#1-1-2-顺序表的遍历" class="headerlink" title="1.1.2 顺序表的遍历"></a>1.1.2 顺序表的遍历</h4><p>一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。</p>
<p>在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则需要做如下操作：</p>
<ol>
<li><p>让SequenceList实现Iterable接口，重写iterator方法；</p>
</li>
<li><p>在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；</p>
</li>
</ol>
<p>代码：</p>
<pre><code class="java">//顺序表代码
import java.util.Iterator;

public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;{
  //存储元素的数组
  private T[] eles;
  //记录当前顺序表中的元素个数
  private int N;    

  //构造方法
  public SequenceList(int capacity){
    eles = (T[])new Object[capacity];
    N=0;
  }

  //将一个线性表置为空表
  public void clear(){
      N=0;
  }

  //判断当前线性表是否为空表
  public boolean isEmpty(){
      return N==0;
  }

  //获取线性表的长度
  public int length(){
      return N;
  }

  //获取指定位置的元素
  public T get(int i){
      if (i&lt;0 || i&gt;=N){
          throw new RuntimeException(&quot;当前元素不存在！&quot;);
      }
      return eles[i];
  }

  //向线型表中添加元素t
  public void insert(T t){
      if (N==eles.length){
          throw new RuntimeException(&quot;当前表已满&quot;);
      }
      eles[N++] = t;
  }

  //在i元素处插入元素t
  public void insert(int i,T t){
    if (i==eles.length){
        throw new RuntimeException(&quot;当前表已满&quot;);
    }

        if (i&lt;0 || i&gt;N){
            throw new RuntimeException(&quot;插入的位置不合法&quot;);
        }

    //把i位置空出来，i位置及其后面的元素依次向后移动一位
    for (int index=N;index&gt;i;index--){
        eles[index]=eles[index-1];
    }

    //把t放到i位置处
    eles[i]=t;
    //元素数量+1
    N++;
  }

  //删除指定位置i处的元素，并返回该元素
  public T remove(int i){
      if (i&lt;0 || i&gt;N-1){
          throw new RuntimeException(&quot;当前要删除的元素不存在&quot;);
      }
      //记录i位置处的元素
      T result = eles[i];
      //把i位置后面的元素都向前移动一位
      for (int index=i;index&lt;N-1;index++){
          eles[index]=eles[index+1];
      }

        //当前元素数量-1
        N--;
        return result;
    }
    //查找t元素第一次出现的位置
  public int indexOf(T t){
    if(t==null){
        throw new RuntimeException(&quot;查找的元素不合法&quot;);
    }
    for (int i = 0; i &lt; N; i++) {
      if (eles[i].equals(t)){
          return i;
      }
      }
      return -1;
  }


  //打印当前线性表的元素
  public void showEles(){
    for (int i = 0; i &lt; N; i++) {
        System.out.print(eles[i]+&quot; &quot;);
    }
      System.out.println();
  }


  @Override
  public Iterator iterator() {
      return new SIterator();
  }

  private class SIterator implements Iterator{
    private int cur;
    public SIterator(){
        this.cur=0;
      }
    @Override
    public boolean hasNext() {
        return cur&lt;N;
    }

    @Override
    public T next() {
        return eles[cur++];
    }
    }
}

//测试代码
public class Test {
  public static void main(String[] args) throws Exception {
    SequenceList&lt;String&gt; squence = new SequenceList&lt;&gt;(5);
    //测试遍历
    squence.insert(0, &quot;姚明&quot;);
    squence.insert(1, &quot;科比&quot;);
    squence.insert(2, &quot;麦迪&quot;);
    squence.insert(3, &quot;艾佛森&quot;);
    squence.insert(4, &quot;卡特&quot;);

    for (String s : squence) {
        System.out.println(s);
    }
  }
}</code></pre>
<h4 id="1-1-3-顺序表的容量可变"><a href="#1-1-3-顺序表的容量可变" class="headerlink" title="1.1.3 顺序表的容量可变"></a>1.1.3 顺序表的容量可变</h4><p>在之前的实现中，当我们使用SequenceList时，先new SequenceList(5)创建一个对象，创建对象时就需要指定容器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的容量的伸缩性。</p>
<p>考虑容器的容量伸缩性，其实就是改变存储数据元素的数组的大小，那我们需要考虑什么时候需要改变数组的大小？</p>
<ol>
<li>添加元素时：</li>
</ol>
<p>添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个是原数组两倍容量的新数组存储元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012049945.png" alt></p>
<ol start="2">
<li>移除元素时：</li>
</ol>
<p>移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量的1/2的新数组存储元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012049845.png" alt></p>
<p><strong>顺序表的容量可变代码：</strong></p>
<pre><code class="java">//顺序表代码
public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;{

  //存储元素的数组
  private T[] eles;
  //记录当前顺序表中的元素个数
  private int N;

  //构造方法
  public SequenceList(int capacity){
      eles = (T[])new Object[capacity];
      N=0;
  }

  //将一个线性表置为空表
  public void clear(){
      N=0;
  }

  //判断当前线性表是否为空表
  public boolean isEmpty(){
      return N==0;
  }

  //获取线性表的长度
  public int length(){
      return N;
  }

  //获取指定位置的元素
  public T get(int i){
    if (i&lt;0 || i&gt;=N){
        throw new RuntimeException(&quot;当前元素不存在！&quot;);
    }
      return eles[i];
  }

  //向线型表中添加元素t
  public void insert(T t){
    if (N==eles.length){
        resize(eles.length*2);
    }
      eles[N++] = t;
  }

  //在i元素处插入元素t
  public void insert(int i,T t){

    if (i&lt;0 || i&gt;N){
        throw new RuntimeException(&quot;插入的位置不合法&quot;);
    }
    //元素已经放满了数组，需要扩容
    if (N==eles.length){
        resize(eles.length*2);
    }


      //把i位置空出来，i位置及其后面的元素依次向后移动一位
    for (int index=N-1;index&gt;i;index--){
          eles[index]=eles[index-1];
      }

      //把t放到i位置处
      eles[i]=t;
      //元素数量+1
      N++;
  }

  //删除指定位置i处的元素，并返回该元素
  public T remove(int i){
    if (i&lt;0 || i&gt;N-1){
        throw new RuntimeException(&quot;当前要删除的元素不存在&quot;);
    }

    //记录i位置处的元素
    T result = eles[i];
      //把i位置后面的元素都向前移动一位
    for (int index=i;index&lt;N-1;index++){
        eles[index]=eles[index+1];
    }

      //当前元素数量-1
      N--;

    //当元素已经不足数组大小的1/4,则重置数组的大小
    if (N&gt;0 &amp;&amp; N&lt;eles.length/4){
        resize(eles.length/2);
    }

    return result;
  }
  //查找t元素第一次出现的位置
  public int indexOf(T t){
    if(t==null){
        throw new RuntimeException(&quot;查找的元素不合法&quot;);
    }

    for (int i = 0; i &lt; N; i++) {
      if (eles[i].equals(t)){
          return i;
      }
      }
      return -1;
  }

  //打印当前线性表的元素
  public void showEles(){
    for (int i = 0; i &lt; N; i++) {
        System.out.print(eles[i]+&quot; &quot;);
    }

      System.out.println();
  }


  @Override
  public Iterator iterator() {
      return new SIterator();
  }

  private class SIterator implements Iterator{
    private int cur;
    public SIterator(){
        this.cur=0;
      }
    @Override
    public boolean hasNext() {
        return cur&lt;N;
    }

    @Override
    public T next() {
        return eles[cur++];
    }
  }

  //改变容量
  private void resize(int newSize){
    //记录旧数组
    T[] temp = eles;
    //创建新数组
    eles = (T[]) new Object[newSize];
    //把旧数组中的元素拷贝到新数组
    for (int i = 0; i &lt; N; i++) {
        eles[i] = temp[i];
    }
  }

  public int capacity(){
      return eles.length;
  }
}
//测试代码
public class Test {
  public static void main(String[] args) throws Exception {
    SequenceList&lt;String&gt; squence = new SequenceList&lt;&gt;(5);
    //测试遍历
    squence.insert(0, &quot;姚明&quot;);
    squence.insert(1, &quot;科比&quot;);
    squence.insert(2, &quot;麦迪&quot;);
    squence.insert(3, &quot;艾佛森&quot;);
    squence.insert(4, &quot;卡特&quot;);

    System.out.println(squence.capacity());

    squence.insert(5,&quot;aa&quot;);
    System.out.println(squence.capacity());
    squence.insert(5,&quot;aa&quot;);
    squence.insert(5,&quot;aa&quot;);
    squence.insert(5,&quot;aa&quot;);
    squence.insert(5,&quot;aa&quot;);
    squence.insert(5,&quot;aa&quot;);
    System.out.println(squence.capacity());
    squence.remove(1);
    squence.remove(1);
    squence.remove(1);
    squence.remove(1);
    squence.remove(1);
    squence.remove(1);
    squence.remove(1);
    System.out.println(squence.capacity());
  }
}</code></pre>
<h4 id="1-1-4-顺序表的时间复杂度"><a href="#1-1-4-顺序表的时间复杂度" class="headerlink" title="1.1.4 顺序表的时间复杂度"></a>1.1.4 顺序表的时间复杂度</h4><p>get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);</p>
<p>insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为O(n);</p>
<p>remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为O(n);</p>
<p>由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显</p>
<h4 id="1-1-5-java中ArrayList实现"><a href="#1-1-5-java中ArrayList实现" class="headerlink" title="1.1.5 java中ArrayList实现"></a>1.1.5 java中ArrayList实现</h4><p>java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。</p>
<ol>
<li><p>是否用数组实现；</p>
</li>
<li><p>有没有扩容操作；</p>
</li>
<li><p>有没有提供遍历方式；</p>
</li>
</ol>
<h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>之前我们已经使用顺序存储结构实现了线性表，我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是增删的效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。这个问题有没有解决方案呢？有，我们可以使用另外一种存储结构实现线性表，链式存储结构。</p>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012059174.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012059126.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205012059566.png" alt></p>
<p>那我们如何使用链表呢？按照面向对象的思想，我们可以设计一个类，来描述结点这个事物，用一个属性描述这个结点存储的元素，用来另外一个属性描述这个结点的下一个结点。</p>
<p><strong>结点API设计：</strong> </p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node next) : 创建Node 对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据<br>Node next：指向下一个结点</td>
</tr>
</tbody></table>
<p><strong>结点类实现：</strong> </p>
<pre><code class="java">public class Node&lt;T&gt; {
  //存储元素
  public T item;
  //指向下一个结点
  public Node next;

  public Node(T item, Node next) {
    this.item = item;
    this.next = next;
  }
}</code></pre>
<p><strong>生成链表：</strong> </p>
<pre><code class="java">public static void main(String[] args) throws Exception {
  //构建结点
  Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(11, null);
  Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(13, null);
  Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(12, null);
  Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(8, null);
  Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(9, null);

  //生成链表
  first.next = second;
  second.next = third;
  third.next = fourth;
  fourth.next = fifth;
}</code></pre>
<hr>
<h4 id="1-2-1-单向链表"><a href="#1-2-1-单向链表" class="headerlink" title="1.2.1 单向链表"></a>1.2.1 单向链表</h4><p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020008963.png" alt></p>
<h5 id="1-2-1-1-单向链表API设计"><a href="#1-2-1-1-单向链表API设计" class="headerlink" title="1.2.1.1 单向链表API设计"></a>1.2.1.1 单向链表API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th>LinkList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()：创建LinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置线性表<br>2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<h5 id="1-2-1-2-单向链表代码实现"><a href="#1-2-1-2-单向链表代码实现" class="headerlink" title="1.2.1.2 单向链表代码实现"></a>1.2.1.2 单向链表代码实现</h5><pre><code class="java">//单向列表代码
import java.util.Iterator;

public class LinkList&lt;T&gt; implements Iterable&lt;T&gt; {
  //记录头结点
  private Node head;
  //记录链表的长度
  private int N;

  public LinkList(){
    //初始化头结点
    head = new Node(null,null);
    N=0;
  }

  //清空链表
  public void clear(){
      head.next=null;
    head.item=null;
        N=0;
    }

  //获取链表的长度
  public int length(){
      return N;
  }

  //判断链表是否为空
  public boolean isEmpty(){
      return N==0;
  }

  //获取指定位置i出的元素
  public T get(int i){
    if (i&lt;0||i&gt;=N){
        throw new RuntimeException(&quot;位置不合法！&quot;);
    }
    Node n = head.next;
    for (int index = 0; index &lt; i; index++) {
        n = n.next;
    }
        return n.item;
    }

  //向链表中添加元素t
  public void insert(T t){
    //找到最后一个节点
    Node n = head;
    while(n.next!=null){
        n = n.next;
    }
    Node newNode = new Node(t, null);
    n.next = newNode;
    //链表长度+1
    N++;
    }

  //向指定位置i处，添加元素t
  public void insert(int i,T t){
    if (i&lt;0||i&gt;=N){
        throw new RuntimeException(&quot;位置不合法！&quot;);
    }

    //寻找位置i之前的结点
    Node pre = head;
    for (int index = 0; index &lt;=i-1; index++) {
        pre = pre.next;
    }
    //位置i的结点
    Node curr = pre.next;

    //构建新的结点，让新结点指向位置i的结点
    Node newNode = new Node(t, curr);
    //让之前的结点指向新结点
    pre.next = newNode;
    //长度+1
    N++;
    }

  //删除指定位置i处的元素，并返回被删除的元素
  public T remove(int i){
    if (i&lt;0 || i&gt;=N){
        throw new RuntimeException(&quot;位置不合法&quot;);
    }

    //寻找i之前的元素
    Node pre = head;
    for (int index = 0; index &lt;=i-1; index++) {
        pre = pre.next;
      }

    //当前i位置的结点
    Node curr = pre.next;
    //前一个结点指向下一个结点，删除当前结点
    pre.next = curr.next;
    //长度-1
    N--;
    return curr.item;
  }

  //查找元素t在链表中第一次出现的位置
  public int indexOf(T t){
      Node n = head;
    for (int i = 0;n.next!=null;i++){
        n = n.next;
        if (n.item.equals(t)){
            return i;
          }
      }
      return -1;
  }


  //结点类
  private class Node{

      //存储数据
      T item;
      //下一个结点
      Node next;

      public Node(T item, Node next) {
      this.item = item;
      this.next = next;
    }
  }

  @Override
  public Iterator iterator() {
      return new LIterator();
  }

  private class LIterator implements Iterator&lt;T&gt;{
      private Node n;

      public LIterator() {
          this.n = head;
      }

    @Override
    public boolean hasNext() {
        return n.next!=null;
    }

    @Override
    public T next() {
      n = n.next;
      return n.item;
    }
    }
}
//测试代码
public class Test {
  public static void main(String[] args) throws Exception {

    LinkList&lt;String&gt; list = new LinkList&lt;&gt;();
    list.insert(0,&quot;张三&quot;);
    list.insert(1,&quot;李四&quot;);
    list.insert(2,&quot;王五&quot;);
    list.insert(3,&quot;赵六&quot;);
    //测试length方法
    for (String s : list) {
        System.out.println(s);
    }
    System.out.println(list.length());
    System.out.println(&quot;-------------------&quot;);
    //测试get方法
    System.out.println(list.get(2));
    System.out.println(&quot;------------------------&quot;);
    //测试remove方法
    String remove = list.remove(1);
    System.out.println(remove);
    System.out.println(list.length());
    System.out.println(&quot;----------------&quot;);;
    for (String s : list) {
        System.out.println(s);
      }
  }
}</code></pre>
<h4 id="1-2-2-双向链表"><a href="#1-2-2-双向链表" class="headerlink" title="1.2.2 双向链表"></a>1.2.2 双向链表</h4><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020044403.png" alt></p>
<p>按照面向对象的思想，我们需要设计一个类，来描述结点这个事物。由于结点是属于链表的，所以我们把结点类作为链表类的一个内部类来实现</p>
<h5 id="1-2-2-1-结点API设计"><a href="#1-2-2-1-结点API设计" class="headerlink" title="1.2.2.1 结点API设计"></a>1.2.2.1 结点API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node pre,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据<br>Node next：指向下一个结点<br>Node pre:指向上一个结点</td>
</tr>
</tbody></table>
<h5 id="1-2-2-2-双向链表API设计"><a href="#1-2-2-2-双向链表API设计" class="headerlink" title="1.2.2.2 双向链表API设计"></a>1.2.2.2 双向链表API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th>TowWayLinkList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TowWayLinkList()：创建TowWayLinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置线性表<br>2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。<br>9.public T getFirst():获取第一个元素<br>10.public T getLast():获取最后一个元素</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node first:记录首结点<br>2.private Node last:记录尾结点<br>3.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<h5 id="1-2-2-3-双向链表代码实现"><a href="#1-2-2-3-双向链表代码实现" class="headerlink" title="1.2.2.3 双向链表代码实现"></a>1.2.2.3 双向链表代码实现</h5><pre><code class="java">//双向链表代码
import java.util.Iterator;

public class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt;{
  //首结点
  private Node head;
  //最后一个结点
  private Node last;

  //链表的长度
  private int N;

  public TowWayLinkList() {
    last = null;
    head = new Node(null,null,null);
    N=0;
  }

  //清空链表
  public void clear(){
    last=null;
    head.next=last;
    head.pre=null;
    head.item=null;
    N=0;
  }

  //获取链表长度
  public int length(){
      return N;
  }

  //判断链表是否为空
  public boolean isEmpty(){
      return N==0;
  }

  //插入元素t
  public void insert(T t){
    if (last==null){
        last = new Node(t,head,null);
        head.next = last;
    }else{
      Node oldLast = last;
      Node node = new Node(t, oldLast, null);
      oldLast.next = node;
      last = node;
      }

      //长度+1
      N++;
  }

  //向指定位置i处插入元素t
  public void insert(int i,T t){
    if (i&lt;0 || i&gt;=N){
        throw new RuntimeException(&quot;位置不合法&quot;);
    }

    //找到位置i的前一个结点
    Node pre = head;
    for (int index = 0; index &lt; i; index++) {
      pre = pre.next;
    }
    //当前结点
    Node curr = pre.next;
    //构建新结点
    Node newNode = new Node(t, pre, curr);
    curr.pre= newNode;
    pre.next = newNode;
    //长度+1
    N++;
    }

  //获取指定位置i处的元素
  public T get(int i){

    if (i&lt;0||i&gt;=N){
      throw new RuntimeException(&quot;位置不合法&quot;);
    }
    //寻找当前结点
    Node curr = head.next;
    for (int index = 0; index &lt;i; index++) {
        curr = curr.next;
    }
      return curr.item;
  }

  //找到元素t在链表中第一次出现的位置
  public int indexOf(T t){
    Node n= head;
    for (int i=0;n.next!=null;i++){
        n = n.next;
        if (n.next.equals(t)){
            return i;
        }
      }
      return -1;
  }

  //删除位置i处的元素，并返回该元素
  public T remove(int i){
    if (i&lt;0 || i&gt;=N){
        throw new RuntimeException(&quot;位置不合法&quot;);
    }

    //寻找i位置的前一个元素
    Node pre = head;
    for (int index = 0; index &lt;i ; index++) {
        pre = pre.next;
    }
    //i位置的元素
    Node curr = pre.next;
    //i位置的下一个元素
    Node curr_next = curr.next;

    pre.next = curr_next;
    curr_next.pre = pre;
    //长度-1；
    N--;
        return curr.item;
    }

  //获取第一个元素
  public T getFirst(){
    if (isEmpty()){
        return null;
    }
    return head.next.item;
  }

  //获取最后一个元素
  public T getLast(){
    if (isEmpty()){
        return null;
    }
      return last.item;
  }

  @Override
  public Iterator&lt;T&gt; iterator() {
      return new TIterator();
  }

  private class TIterator implements Iterator{
      private Node n = head;

    @Override
    public boolean hasNext() {
      return n.next!=null;
    }

    @Override
    public Object next() {
      n = n.next;
      return n.item;
    }
    }

  //结点类
  private class Node{
    public Node(T item, Node pre, Node next) {
      this.item = item;
      this.pre = pre;
      this.next = next;
    }

    //存储数据
    public T item;
    //指向上一个结点
    public Node pre;
    //指向下一个结点
    public Node next;
  }
}

//测试代码
public class Test {
  public static void main(String[] args) throws Exception {

    TowWayLinkList&lt;String&gt; list = new TowWayLinkList&lt;&gt;();
    list.insert(&quot;乔峰&quot;);

    list.insert(&quot;虚竹&quot;);
    list.insert(&quot;段誉&quot;);
    list.insert(1,&quot;鸠摩智&quot;);
    list.insert(3,&quot;叶二娘&quot;);

    for (String str : list) {
        System.out.println(str);
    }
    System.out.println(&quot;----------------------&quot;);
    String tow = list.get(2);
    System.out.println(tow);
    System.out.println(&quot;-------------------------&quot;);
    String remove = list.remove(3);
    System.out.println(remove);
    System.out.println(list.length());
    System.out.println(&quot;--------------------&quot;);
    System.out.println(list.getFirst());
    System.out.println(list.getLast());
  }
}</code></pre>
<h5 id="1-2-2-4-java中LinkedList实现"><a href="#1-2-2-4-java中LinkedList实现" class="headerlink" title="1.2.2.4 java中LinkedList实现"></a>1.2.2.4 java中LinkedList实现</h5><p>java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法</p>
<ol>
<li><p>底层是否用双向链表实现；</p>
</li>
<li><p>结点类是否有三个域</p>
</li>
</ol>
<h4 id="1-2-3-链表的复杂度分析"><a href="#1-2-3-链表的复杂度分析" class="headerlink" title="1.2.3 链表的复杂度分析"></a>1.2.3 链表的复杂度分析</h4><p>get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O(n)</p>
<p>insert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n);</p>
<p>remove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n)</p>
<p>相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,,同时它并没有涉及的元素的交换。</p>
<p>相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</p>
<h4 id="1-2-4-链表反转"><a href="#1-2-4-链表反转" class="headerlink" title="1.2.4 链表反转"></a>1.2.4 链表反转</h4><p>单链表的反转，是面试中的一个高频题目。</p>
<p><strong>需求：</strong> </p>
<p>原链表中数据为：1-&gt;2-&gt;3&gt;4</p>
<p>反转后链表中数据为：4-&gt;3-&gt;2-&gt;1</p>
<p><strong>反转API：</strong> </p>
<pre><code class="java">public void reverse()：对整个链表反转</code></pre>
<pre><code class="java">public Node reverse(Node curr)：反转链表中的某个结点curr,并把反转后的curr结点返回</code></pre>
<p>使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，直到把最后一个结点反转完毕，整个链表就反转完毕。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020107544.png" alt></p>
<p><strong>代码:</strong></p>
<pre><code class="java">public void reverse(){
  if (N==0){
    //当前是空链表，不需要反转
    return;
  }
  reverse(head.next);
}

/**
*
* @param curr 当前遍历的结点
* @return 反转后当前结点上一个结点
*/
public Node reverse(Node curr){
  //已经到了最后一个元素
  if (curr.next==null){
    //反转后，头结点应该指向原链表中的最后一个元素
    head.next=curr;
    return curr;
  }
  //当前结点的上一个结点
  Node pre = reverse(curr.next);
  pre.next = curr;
  //当前结点的下一个结点设为null
  curr.next=null;
  //返回当前结点
  return curr;
}

//测试代码
public class Test {
  public static void main(String[] args) throws Exception {

    LinkList&lt;Integer&gt; list = new LinkList&lt;&gt;();
    list.insert(1);
    list.insert(2);
    list.insert(3);
    list.insert(4);

    for (Integer i : list) {
        System.out.print(i+&quot; &quot;);
    }
    System.out.println();
    System.out.println(&quot;--------------------&quot;);
    list.reverse();
    for (Integer i : list) {
        System.out.print(i+&quot; &quot;);
    }
  }
}</code></pre>
<h4 id="1-2-5-快慢指针"><a href="#1-2-5-快慢指针" class="headerlink" title="1.2.5 快慢指针"></a>1.2.5 快慢指针</h4><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然</p>
<p>我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p>
<h5 id="1-2-5-1-中间值问题"><a href="#1-2-5-1-中间值问题" class="headerlink" title="1.2.5.1 中间值问题"></a>1.2.5.1 中间值问题</h5><p>我们先来看下面一段代码，然后完成需求。</p>
<pre><code class="java">//测试类
public class Test {
  public static void main(String[] args) throws Exception {
    Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);
    Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);
    Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);
    Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);
    Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);
    Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);
    Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);


    //完成结点之间的指向
    first.next = second;
    second.next = third;
    third.next = fourth;
    fourth.next = fifth;
    fifth.next = six;
    six.next = seven;

    //查找中间值
    String mid = getMid(first);
    System.out.println(&quot;中间值为：&quot;+mid);
    }

  /**
  * @param first 链表的首结点
  * @return 链表的中间结点的值
  */
  public static String getMid(Node&lt;String&gt; first) {
      return null;
  }

  //结点类
  private static class Node&lt;T&gt; {
    //存储数据
    T item;
    //下一个结点
    Node next;

    public Node(T item, Node next) {
      this.item = item;
      this.next = next;
      }
  }
}</code></pre>
<p><strong>需求：</strong></p>
<p>请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。</p>
<p>利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。</p>
<p>如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020114819.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020114147.png" alt></p>
<p><strong>代码：</strong></p>
<pre><code class="java">/**
* @param first 链表的首结点
* @return 链表的中间结点的值
*/
public static String getMid(Node&lt;String&gt; first) {
  Node&lt;String&gt; slow = first;
  Node&lt;String&gt; fast = first;
  while(fast!=null &amp;&amp; fast.next!=null){
      fast=fast.next.next;
      slow=slow.next;
  }
  return slow.item;
}</code></pre>
<h5 id="1-2-5-2-单向链表是否有环问题"><a href="#1-2-5-2-单向链表是否有环问题" class="headerlink" title="1.2.5.2 单向链表是否有环问题"></a>1.2.5.2 单向链表是否有环问题</h5><p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020116502.png" alt></p>
<p>看下面代码，完成需求：</p>
<pre><code class="java">//测试类
public class Test {
  public static void main(String[] args) throws Exception {
    Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);
    Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);
    Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);
    Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);
    Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);
    Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);
    Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);

    //完成结点之间的指向
    first.next = second;
    second.next = third;
    third.next = fourth;
    fourth.next = fifth;
    fifth.next = six;
    six.next = seven;
    //产生环
    seven.next = third;

    //判断链表是否有环
    boolean circle = isCircle(first);
    System.out.println(&quot;first链表中是否有环：&quot;+circle);
     }

  /**
  * 判断链表中是否有环
  * @param first 链表首结点
  * @return ture为有环，false为无环
  */
  public static boolean isCircle(Node&lt;String&gt; first) {

      return false;
  }

  //结点类
  private static class Node&lt;T&gt; {
    //存储数据
    T item;
    //下一个结点
    Node next;

    public Node(T item, Node next) {
      this.item = item;
      this.next = next;
    }
    }
}</code></pre>
<p><strong>需求：</strong> </p>
<p>请完善测试类Test中的isCircle方法，返回链表中是否有环。</p>
<p>使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020119545.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020119424.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020120349.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020120274.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020121155.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020121789.png" alt></p>
<p><strong>代码：</strong></p>
<pre><code class="java">/**
* 判断链表中是否有环
* @param first 链表首结点
* @return ture为有环，false为无环
*/
public static boolean isCircle(Node&lt;String&gt; first) {
  Node&lt;String&gt; slow = first;
  Node&lt;String&gt; fast = first;
    while(fast!=null &amp;&amp; fast.next!=null){
        fast = fast.next.next;

        slow = slow.next;
      if (fast.equals(slow)){
            return true;
        }
    }
    return false;
}</code></pre>
<h5 id="1-2-5-3-有环链表入口问题"><a href="#1-2-5-3-有环链表入口问题" class="headerlink" title="1.2.5.3 有环链表入口问题"></a>1.2.5.3 有环链表入口问题</h5><p>同样看下面这段代码，完成需求：</p>
<pre><code class="java">//测试类
public class Test {
  public static void main(String[] args) throws Exception {
    Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);
    Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);
    Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);
    Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);
    Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);
    Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);
    Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);

    //完成结点之间的指向
    first.next = second;
    second.next = third;
    third.next = fourth;
    fourth.next = fifth;
    fifth.next = six;
    six.next = seven;
    //产生环
    seven.next = third;

    //查找环的入口结点
    Node&lt;String&gt; entrance = getEntrance(first);
    System.out.println(&quot;first链表中环的入口结点元素为：&quot;+entrance.item);
  }

  /**
    * 查找有环链表中环的入口结点
    * @param first 链表首结点
    * @return 环的入口结点
    */
  public static Node getEntrance(Node&lt;String&gt; first) {

    return null;
  }
  //结点类
  private static class Node&lt;T&gt; {
    //存储数据
    T item;
    //下一个结点
    Node next;

    public Node(T item, Node next) {
      this.item = item;
      this.next = next;
    }
     }
}</code></pre>
<p><strong>需求：</strong></p>
<p>请完善Test类中的getEntrance方法，查找有环链表中环的入口结点。</p>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020126907.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020127944.png" alt></p>
<p><strong>代码：</strong></p>
<pre><code class="java">/**
* 查找有环链表中环的入口结点
* @param first 链表首结点
* @return 环的入口结点
*/
public static Node getEntrance(Node&lt;String&gt; first) {
  Node&lt;String&gt; slow = first;
  Node&lt;String&gt; fast = first;
  Node&lt;String&gt; temp = null;
    while(fast!=null &amp;&amp; fast.next!=null){
        fast = fast.next.next;
        slow=slow.next;
    if (fast.equals(slow)){
        temp = first;
        continue;
    }
    if (temp!=null){
        temp=temp.next;
        if (temp.equals(slow)){
            return temp;
        }
    }
    }
    return null;
}</code></pre>
<h4 id="1-2-6-循环链表"><a href="#1-2-6-循环链表" class="headerlink" title="1.2.6 循环链表"></a>1.2.6 循环链表</h4><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020129295.png" alt></p>
<p><strong>循环链表的构建：</strong></p>
<pre><code class="java">public class Test {
  public static void main(String[] args) throws Exception {
    //构建结点
    Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(1, null);
    Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(2, null);
    Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(3, null);
    Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(4, null);
    Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(5, null);
    Node&lt;Integer&gt; six = new Node&lt;Integer&gt;(6, null);
    Node&lt;Integer&gt; seven = new Node&lt;Integer&gt;(7, null);
      //构建单链表
    first.next = second;
    second.next = third;
    third.next = fourth;
    fourth.next = fifth;
    fifth.next = six;
    six.next = seven;

    //构建循环链表,让最后一个结点指向第一个结点
    seven.next = first;
  }
}</code></pre>
<h4 id="1-2-7-约瑟夫问题"><a href="#1-2-7-约瑟夫问题" class="headerlink" title="1.2.7 约瑟夫问题"></a>1.2.7 约瑟夫问题</h4><p><strong>问题描述：</strong></p>
<p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。</p>
<p><strong>问题转换：</strong></p>
<p>41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。</p>
<ol>
<li><p>编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；</p>
</li>
<li><p>自退出那个人开始的下一个人再次从1开始报数，以此类推；</p>
</li>
<li><p>求出最后退出的那个人的编号。</p>
</li>
</ol>
<p><strong>图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020132577.png" alt></p>
<p><strong>解题思路：</strong> </p>
<ol>
<li><p>构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；</p>
</li>
<li><p>使用计数器count，记录当前报数的值；</p>
</li>
<li><p>遍历链表，每循环一次，count++；</p>
</li>
<li><p>判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；</p>
</li>
</ol>
<p><strong>代码:</strong></p>
<pre><code class="java">public class Test {
  public static void main(String[] args) throws Exception {
    //1.构建循环链表
    Node&lt;Integer&gt; first = null;
    //记录前一个结点
    Node&lt;Integer&gt; pre = null;
    for (int i = 1; i &lt;= 41; i++) {
        //第一个元素
        if (i==1){
            first = new Node(i,null);

            pre = first;
          continue;
          }

            Node&lt;Integer&gt; node = new Node&lt;&gt;(i,null);
            pre.next = node;
      pre = node;
      if (i==41){
          //构建循环链表，让最后一个结点指向第一个结点
          pre.next=first;
      }
        }

    //2.使用count，记录当前的报数值
    int count=0;
    //3.遍历链表，每循环一次，count++
    Node&lt;Integer&gt; n = first;
    Node&lt;Integer&gt; before = null;
    while(n!=n.next){
      //4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；
      count++;
      if (count==3){
        //删除当前结点
        before.next = n.next;
        System.out.print(n.item+&quot;,&quot;);
        count=0;
        n = n.next;
      }else{
        before=n;
        n = n.next;
      }
    }
        /*打印剩余的最后那个人*/
        System.out.println(n.item);
    }
}</code></pre>
<hr>
<h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><h4 id="1-3-1-栈概述"><a href="#1-3-1-栈概述" class="headerlink" title="1.3.1 栈概述"></a>1.3.1 栈概述</h4><h5 id="1-3-1-1-生活中的栈"><a href="#1-3-1-1-生活中的栈" class="headerlink" title="1.3.1.1 生活中的栈"></a>1.3.1.1 生活中的栈</h5><p>存储货物或供旅客住宿的地方,可引申为仓库、中转站 。例如我们现在生活中的酒店，在古时候叫客栈，是供旅客休息的地方，旅客可以进客栈休息，休息完毕后就离开客栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020136243.png" alt></p>
<h5 id="1-3-1-2-计算机中的栈"><a href="#1-3-1-2-计算机中的栈" class="headerlink" title="1.3.1.2 计算机中的栈"></a>1.3.1.2 计算机中的栈</h5><p>我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，又可以从栈中出去。</p>
<p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p>
<p>我们称数据进入到栈的动作为<strong>压栈</strong>，数据从栈中出去的动作为<strong>弹栈</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020137625.png" alt></p>
<h4 id="1-3-2-栈的实现"><a href="#1-3-2-栈的实现" class="headerlink" title="1.3.2 栈的实现"></a>1.3.2 栈的实现</h4><h5 id="1-3-2-1-栈API设计"><a href="#1-3-2-1-栈API设计" class="headerlink" title="1.3.2.1 栈API设计"></a>1.3.2.1 栈API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th>Stack</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Stack)：创建Stack对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数</td>
</tr>
</tbody></table>
<h5 id="1-3-2-2-栈代码实现"><a href="#1-3-2-2-栈代码实现" class="headerlink" title="1.3.2.2 栈代码实现"></a>1.3.2.2 栈代码实现</h5><pre><code class="java">//栈代码
import java.util.Iterator;

public class Stack&lt;T&gt; implements Iterable&lt;T&gt;{
  //记录首结点
  private Node head;
  //栈中元素的个数
  private int N;

  public Stack() {
    head = new Node(null,null);
    N=0;
    }

  //判断当前栈中元素个数是否为0
  public boolean isEmpty(){
      return N==0;
  }

  //把t元素压入栈
  public void push(T t){
    Node oldNext = head.next;
    Node node = new Node(t, oldNext);
    head.next = node;
    //个数+1
    N++;
  }

  //弹出栈顶元素
  public T pop(){
      Node oldNext = head.next;

    if (oldNext==null){
      return null;
    }
    //删除首个元素
    head.next = head.next.next;
    //个数-1
    N--;
        return oldNext.item;
    }


  //获取栈中元素的个数
  public int size(){
      return N;
  }

  @Override
  public Iterator&lt;T&gt; iterator() {
      return new SIterator();
  }

  private class SIterator implements Iterator&lt;T&gt;{
    private Node n = head;
    @Override
    public boolean hasNext() {
        return n.next!=null;
    }

    @Override
    public T next() {
      Node node = n.next;
      n = n.next;
      return node.item;
    }
    }


  private class Node{
      public T item;
      public Node next;

      public Node(T item, Node next) {
      this.item = item;
      this.next = next;
      }
  }
}

//测试代码
public class Test {
  public static void main(String[] args) throws Exception {
    Stack&lt;String&gt; stack = new Stack&lt;&gt;();
    stack.push(&quot;a&quot;);

    stack.push(&quot;b&quot;);
    stack.push(&quot;c&quot;);
    stack.push(&quot;d&quot;);
    for (String str : stack) {
        System.out.print(str+&quot; &quot;);
    }
    System.out.println(&quot;-----------------------------&quot;);
    String result = stack.pop();
    System.out.println(&quot;弹出了元素：&quot;+result);
    System.out.println(stack.size());
  }
}</code></pre>
<h4 id="1-3-3-案例"><a href="#1-3-3-案例" class="headerlink" title="1.3.3 案例"></a>1.3.3 案例</h4><h5 id="1-3-3-1-括号匹配问题"><a href="#1-3-3-1-括号匹配问题" class="headerlink" title="1.3.3.1 括号匹配问题"></a>1.3.3.1 括号匹配问题</h5><p><strong>问题描述:</strong></p>
<pre><code class="java">给定一个字符串，里边可能包含&quot;()&quot;小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。

例如：
  &quot;(上海)(长安)&quot;：正确匹配
  &quot;上海((长安))&quot;：正确匹配
  &quot;上海(长安(北京)(深圳)南京)&quot;:正确匹配
  &quot;上海(长安))&quot;：错误匹配
  &quot;((上海)长安&quot;：错误匹配</code></pre>
<p><strong>示例代码：</strong></p>
<pre><code class="java">public class BracketsMatch {
  public static void main(String[] args) {
    String str = &quot;(上海(长安)())&quot;;
    boolean match = isMatch(str);
    System.out.println(str+&quot;中的括号是否匹配：&quot;+match);
  }

  /**
  * 判断str中的括号是否匹配
  * @param str 括号组成的字符串
  * @return 如果匹配，返回true，如果不匹配，返回false
  */
  public static boolean isMatch(String str){
      return false;
  }
}</code></pre>
<p>请完善 isMath方法。</p>
<p><strong>分析：</strong></p>
<pre><code class="java">1.创建一个栈用来存储左括号
2.从左往右遍历字符串，拿到每一个字符
3.判断该字符是不是左括号，如果是，放入栈中存储
4.判断该字符是不是右括号，如果不是，继续下一次循环
5.如果该字符是右括号，则从栈中弹出一个元素t；
6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号
7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020203486.png" alt></p>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public class BracketsMatch {
  public static void main(String[] args) {
    String str = &quot;(fdafds(fafds)())&quot;;
    boolean match = isMatch(str);
    System.out.println(str + &quot;中的括号是否匹配：&quot; + match);
  }

  /**
  * 判断str中的括号是否匹配
  *
  * @param str 括号组成的字符串
  * @return 如果匹配，返回true，如果不匹配，返回false
  */
  public static boolean isMatch(String str) {
    //1.创建一个栈用来存储左括号
    Stack&lt;String&gt; chars = new Stack&lt;&gt;();
    //2.从左往右遍历字符串，拿到每一个字符
    for (int i = 0; i &lt; str.length(); i++) {
        String currChar = str.charAt(i) + &quot;&quot;;
        //3.判断该字符是不是左括号，如果是，放入栈中存储
          if (currChar.equals(&quot;(&quot;)) {
              chars.push(currChar);

          } else if (currChar.equals(&quot;)&quot;)) {//4.判断该字符是不是右括号，如果不是，继续下一次循环
              //5.如果该字符是右括号，则从栈中弹出一个元素t；
              String t = chars.pop();
              //6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号
              if (t == null) {
                  return false;
              }
          }
      }
    //7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配
    if (chars.size() == 0) {
      return true;
    } else {
      return false;
    }
  }
}</code></pre>
<h5 id="1-3-3-2-逆波兰表达式求值问题"><a href="#1-3-3-2-逆波兰表达式求值问题" class="headerlink" title="1.3.3.2 逆波兰表达式求值问题"></a>1.3.3.2 逆波兰表达式求值问题</h5><p>逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。</p>
<p><strong>中缀表达式：</strong> </p>
<p>中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。</p>
<p>中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。</p>
<p><strong>逆波兰表达式(后缀表达式)：</strong> </p>
<p>逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。</p>
<table>
<thead>
<tr>
<th>中缀表达式</th>
<th>逆波兰表达式</th>
</tr>
</thead>
<tbody><tr>
<td>a+b</td>
<td>ab+</td>
</tr>
<tr>
<td>a+(b-c)</td>
<td>abc-+</td>
</tr>
<tr>
<td>a+(b-c)*d</td>
<td>abc-d*+</td>
</tr>
<tr>
<td>a*(b-c)+d</td>
<td>abc-*d+</td>
</tr>
</tbody></table>
<p><strong>需求：</strong> </p>
<p>给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。</p>
<pre><code class="java">public class ReversePolishNotation {
  public static void main(String[] args) {
    //中缀表达式3*（17-15）+18/6的逆波兰表达式如下
    String[] notation = {&quot;3&quot;, &quot;17&quot;, &quot;15&quot;, &quot;-&quot;, &quot;*&quot;,&quot;18&quot;, &quot;6&quot;,&quot;/&quot;,&quot;+&quot;};
    int result = caculate(notation);
    System.out.println(&quot;逆波兰表达式的结果为：&quot;+result);
  }

  /**
  * @param notaion 逆波兰表达式的数组表示方式
  * @return 逆波兰表达式的计算结果
  */
  public static int caculate(String[] notaion){
      return -1;
  }
}</code></pre>
<p>完善caculate方法，计算出逆波兰表达式的结果。</p>
<p><strong>分析：</strong></p>
<pre><code class="java">1.创建一个栈对象oprands存储操作数
2.从左往右遍历逆波兰表达式，得到每一个字符串
3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中
4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2
5.使用该运算符计算o1和o2，得到结果result
6.把该结果压入oprands栈中
7.遍历结束后，拿出栈中最终的结果返回</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020215687.png" alt></p>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public class ReversePolishNotation {
  public static void main(String[] args) {
    //中缀表达式3*（17-15）+18/6的逆波兰表达式如下
    String[] notation = {&quot;3&quot;, &quot;17&quot;, &quot;15&quot;, &quot;-&quot;, &quot;*&quot;, &quot;18&quot;, &quot;6&quot;, &quot;/&quot;, &quot;+&quot;};
    int result = caculate(notation);
    System.out.println(&quot;逆波兰表达式的结果为：&quot; + result);
  }

  /**
  * @param notaion 逆波兰表达式的数组表示方式
  * @return 逆波兰表达式的计算结果
  */
  public static int caculate(String[] notaion) {
    //1.创建一个栈对象oprands存储操作数
    Stack&lt;Integer&gt; oprands = new Stack&lt;&gt;();
    //2.从左往右遍历逆波兰表达式，得到每一个字符串
    for (int i = 0; i &lt; notaion.length; i++) {
      String curr = notaion[i];
      //3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中
      Integer o1;
      Integer o2;
      Integer result;
      switch (curr) {
          case &quot;+&quot;:
          //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2
          o1 = oprands.pop();
          o2 = oprands.pop();
          //5.使用该运算符计算o1和o2，得到结果result
          result = o2 + o1;
          //6.把该结果压入oprands栈中
          oprands.push(result);
          break;
        case &quot;-&quot;:
          //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2
          o1 = oprands.pop();
          o2 = oprands.pop();
          //5.使用该运算符计算o1和o2，得到结果result
          result = o2 - o1;
          //6.把该结果压入oprands栈中
          oprands.push(result);
          break;
               case &quot;*&quot;:
          //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2
          o1 = oprands.pop();
          o2 = oprands.pop();
          //5.使用该运算符计算o1和o2，得到结果result
          result = o2 * o1;
          //6.把该结果压入oprands栈中
          oprands.push(result);
          break;
            case &quot;/&quot;:
          //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2
          o1 = oprands.pop();
          o2 = oprands.pop();
          //5.使用该运算符计算o1和o2，得到结果result
          result = o2 / o1;
          //6.把该结果压入oprands栈中
          oprands.push(result);
          break;
            default:
          oprands.push(Integer.parseInt(curr));
          break;
        }
    }

    //7.遍历结束后，拿出栈中最终的结果返回
    Integer result = oprands.pop();
    return result;
  }
}</code></pre>
<hr>
<h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tenincense0714/imgbed@master/img/202205020219561.png" alt></p>
<h4 id="1-4-1-队列的API设计"><a href="#1-4-1-队列的API设计" class="headerlink" title="1.4.1 队列的API设计"></a>1.4.1 队列的API设计</h4><table>
<thead>
<tr>
<th>类名</th>
<th>Queue</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Queue()：创建Queue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false<br>2.public int size():获取队列中元素的个数<br>3.public T dequeue():从队列中拿出一个元素<br>4.public void enqueue(T t)：往队列中插入一个元素</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点</td>
</tr>
</tbody></table>
<h4 id="1-4-2-队列的实现"><a href="#1-4-2-队列的实现" class="headerlink" title="1.4.2 队列的实现"></a>1.4.2 队列的实现</h4><pre><code class="java">//队列代码
import java.util.Iterator;

public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{
  //记录首结点
  private Node head;
  //记录最后一个结点
  private Node last;
  //记录队列中元素的个数
  private int N;

  public Queue() {
    head = new Node(null,null);
    last=null;
    N=0;
  }

  //判断队列是否为空
  public boolean isEmpty(){
      return N==0;
  }

  //返回队列中元素的个数
  public int size(){
      return N;
  }

  //向队列中插入元素t
  public void enqueue(T t){
    if (last==null){
        last = new Node(t,null);
        head.next=last;
    }else{
        Node oldLast = last;
        last = new Node(t,null);
      oldLast.next=last;
    }
      //个数+1
      N++;
  }

  //从队列中拿出一个元素
  public T dequeue(){
    if (isEmpty()){
        return null;
    }

    Node oldFirst = head.next;
    head.next = oldFirst.next;
    N--;
    if (isEmpty()){
        last=null;
    }
      return oldFirst.item;
  }

  @Override
  public Iterator&lt;T&gt; iterator() {
      return new QIterator();
  }

  private class QIterator implements Iterator&lt;T&gt;{
      private Node n = head;

    @Override
    public boolean hasNext() {
        return n.next!=null;
    }

    @Override
    public T next() {
      Node node = n.next;
      n = n.next;
      return node.item;
    }
     }

  private class Node{
    public T item;
    public Node next;

    public Node(T item, Node next) {
      this.item = item;
      this.next = next;
    }
  }
}


//测试代码
public class Test {
  public static void main(String[] args) throws Exception {
    Queue&lt;String&gt; queue = new Queue&lt;&gt;();
    queue.enqueue(&quot;a&quot;);
    queue.enqueue(&quot;b&quot;);
    queue.enqueue(&quot;c&quot;);
    queue.enqueue(&quot;d&quot;);
    for (String str : queue) {
    System.out.print(str+&quot; &quot;);
    }
    System.out.println(&quot;-----------------------------&quot;);
    String result = queue.dequeue();
    System.out.println(&quot;出列了元素：&quot;+result);
    System.out.println(queue.size());
  }
}</code></pre>
<hr>
<hr>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanQR.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2022/05/16/Final-Cut-Pro教程/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                Final Cut Pro教程</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2022/04/16/Apollo分布式配置中心/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                Apollo分布式配置中心</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz",
        appKey: "mgOpfzbkHYqU92CV4IDlAUHQ",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>




      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="" class="profile gravatar"><img src="" itemprop="image" alt="" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="" itemprop="url" rel="author"></a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i></p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 TenIncense<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6https://tenincense-1309094827.cos.ap-guangzhou.myqcloud.com/image/202205291139260.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">さくら荘そのTenIncense</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/honjun" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="http://weibo.com/mashirozx?is_all=1" class="fa fa-weibo" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
        <a href="https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/悦读/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/图集/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  图集
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Lab
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/client/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-android faa-vertical" aria-hidden="true"></i>
            客户端
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>