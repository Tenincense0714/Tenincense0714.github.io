<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">Spring | TenIncense</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "さくら荘そのTenIncense";
  mashiro_option.author_name = "TenIncense";
  mashiro_option.site_url = "https://github.com/Tenincense0714/";
  mashiro_option.v_appId = "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz";
  mashiro_option.v_appKey = "mgOpfzbkHYqU92CV4IDlAUHQ";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(1).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(2).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(3).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(4).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(5).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(6).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(7).jpg.webp,https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(8).jpg.webp".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://github.com/Tenincense0714/">
          <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>须知少年凌云志，曾许人间第一流</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/honjun" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="sina">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/sina.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="wangyiyun">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wangyiyun.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">さくら荘その</span>
            <span class="shironeko">TenIncense</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/悦读/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/图集/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          图集
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Lab
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/client/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-android faa-vertical" aria-hidden="true"></i>
                    客户端
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
          <header class="entry-header">
            <h1 class="entry-title">Spring</h1>
            <p class="entry-census">&nbsp;·&nbsp;2021-8-24&nbsp;·&nbsp;<span id="busuanzi_value_page_pv"></span>次阅读</p></p>

            <hr>
          </header>
        
        <div class="entry-content">
          <h2 id="一-Spring核心功能之-IOC"><a href="#一-Spring核心功能之-IOC" class="headerlink" title="一.Spring核心功能之 IOC"></a>一.Spring核心功能之 IOC</h2><h3 id="一、IOC-Inversion-of-Control"><a href="#一、IOC-Inversion-of-Control" class="headerlink" title="一、IOC(Inversion of Control)"></a>一、IOC(Inversion of Control)</h3><ul>
<li><p>控制反转，是一个理论，概念，思想</p>
</li>
<li><p>描述的：把对象的创建，赋值，管理工作都交给代码之外的容器实现，也就是对象的创建是由其它外部资源完成的。</p>
<ul>
<li><strong>控制</strong>：对象的创建，对象的属性赋值，对象之间的关系管理。</li>
<li><strong>反转</strong>：把原来的开发人员的管理，创建对象的权限转移给代码之外的容器实现，由容器代替开发人员管理，创建对象给对象赋值</li>
</ul>
</li>
<li><p>为什么要使用 IOC</p>
<ul>
<li>目的就是减少代码的改动，也能实现不同的功能，实现解耦合。</li>
</ul>
</li>
</ul>
<h3 id="二、Spring-开发步骤"><a href="#二、Spring-开发步骤" class="headerlink" title="二、Spring 开发步骤"></a>二、Spring 开发步骤</h3><h4 id="一、创建-maven-项目"><a href="#一、创建-maven-项目" class="headerlink" title="一、创建 maven 项目"></a>一、创建 maven 项目</h4><p>选择 maven-archetype-quickstart</p>
<h4 id="二、引入依赖"><a href="#二、引入依赖" class="headerlink" title="二、引入依赖"></a>二、引入依赖</h4><pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h4 id="三、定义接口与实体类"><a href="#三、定义接口与实体类" class="headerlink" title="三、定义接口与实体类"></a>三、定义接口与实体类</h4><pre><code class="java">public interface SomeService{
  void doSome();
}</code></pre>
<pre><code class="java">public class SomeServiceImpl implements SomeService{
  public void doSome(){
    System.out.println(&quot;doSome()业务方法&quot;)；
  }
}</code></pre>
<h4 id="四、创建-Spring-配置文件"><a href="#四、创建-Spring-配置文件" class="headerlink" title="四、创建 Spring 配置文件"></a>四、创建 Spring 配置文件</h4><ul>
<li>1.在 src/main/resources/目录中创建 applicationcontext.xml 文件</li>
<li>2.在 xml 文件中声明 bean：就是告诉 spring 要创建某个类的对象</li>
</ul>
<pre><code class="xml">&lt;!--
    id:对象的自定义名称，唯一值
    class:类的权限定名称
--&gt;
&lt;!--
    scope 属性：依赖的作用域
        scope=&quot;singleton&quot; 默认值，单例（你在测试程序中无论调用几次这个 bean 都只能生成一个对象）
         scope=&quot;prototype&quot; 原型，多例，调用几次 bean 就会生成几个对象
--&gt;
&lt;bean id=&quot;someService&quot; class=&quot;com.bjpowernode.service.impl.SomeServiceImpl&quot;  scope=&quot;prototype&quot;/&gt;
&lt;!--创建非自定义的类--&gt;
&lt;bean id=&quot;myDate&quot; class=&quot;java.util.Date&quot; /&gt;</code></pre>
<h4 id="五、定义测试类"><a href="#五、定义测试类" class="headerlink" title="五、定义测试类"></a>五、定义测试类</h4><pre><code class="java">@Test
public void test01(){
  // 指定 spring 配置文件的位置和名称
  String config = &quot;applicationContext&quot;;
  // 创建 spring 容器对象
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  // 从 spring 容器中获取对象，使用 id
  SomeService service = (SomeService)ac.getBean(&quot;someService&quot;);
  // 执行对象的业务方法
  service.doSome();  
}</code></pre>
<hr>
<h2 id="二、IOC技术实现"><a href="#二、IOC技术实现" class="headerlink" title="二、IOC技术实现"></a>二、IOC技术实现</h2><ul>
<li><p><code>DI 是ioc 的技术实现</code></p>
</li>
<li><p>DI （Dependency Injection）：<code>依赖注入</code>，只需要在程序中提供要使用的对象的名称就可以，至于对象如何在容器中创建赋值，查找都由容器内部实现。</p>
</li>
<li><p>spring是使用的di 实现了ioc 的功能，spring 底层创建对象，使用的是反射机制</p>
</li>
</ul>
<h3 id="注入分类"><a href="#注入分类" class="headerlink" title="注入分类"></a>注入分类</h3><h4 id="1-set-注入（设值注入）"><a href="#1-set-注入（设值注入）" class="headerlink" title="1.set 注入（设值注入）"></a>1.set 注入（设值注入）</h4><p>spring 调用类的set 方法，你可以在 set 方法中完成属性赋值</p>
<p><strong>1）简单类型的 set 注入</strong></p>
<pre><code class="xml">&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;&gt;  
    &lt;property name=&quot;属性名字&quot; value=&quot;此属性的值“&gt;
    &lt;property...&gt;
&lt;/bean&gt;</code></pre>
<p>实例：</p>
<blockquote>
<p>一、创建实体类</p>
</blockquote>
<pre><code class="java">public class Student{
  private String name;
  private int age;
  //无参数构造方法
  //setter and getter
  //toString
}</code></pre>
<blockquote>
<p>二、resources 目录中创建 applicationcontext.xml，定义 bean</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba01.Student&quot;&gt;
  &lt;property name=&quot;name&quot; value=&quot;李四&quot; /&gt;
  &lt;property age=&quot;age&quot; value=&quot;20&quot; /&gt;</code></pre>
<blockquote>
<p>三、定义测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test02(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  Student student = (Student)ac.getBean(&quot;MyStudent&quot;);
  System.out.println(student.toString());
}</code></pre>
<p><strong>2)引用类型的 set 注入</strong></p>
<p>当指定 bean 的某属性值为另一 bean 的实例时，通过 ref 指定它们间的引用关系。ref 的值必须为某 bean 的 id 值。</p>
<p>实例：</p>
<blockquote>
<p>⼀、创建实体类</p>
</blockquote>
<pre><code class="java">public class School{
  private String name;
  private String address;
  //setter
  //toString
}</code></pre>
<pre><code class="java">public class Student{
  private String name;
  private String age;
  //声明 School 引用类型
  private School school;
  //setter
  //toString
}</code></pre>
<blockquote>
<p>二、创建 applicationcontext.xml 文件</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba02.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;王五&quot; /&gt;
  &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
  &lt;property name=&quot;school&quot; ref=&quot;MySchool&quot; /&gt;
&lt;/bean&gt; 
&lt;bean id=&quot;MySchool&quot; class=&quot;com.bjpowernode.ba02.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;北京大学&quot; /&gt;
  &lt;property name=&quot;address&quot; value=&quot;北京&quot; /&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>三、创建测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test03(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  Student student = (Student)ac.getBean(&quot;MyStudent&quot;);
  System.out.println(student.toString());
}</code></pre>
<hr>
<h4 id="2-构造注入"><a href="#2-构造注入" class="headerlink" title="2.构造注入"></a>2.构造注入</h4><ul>
<li>Spring 调用类的有参数构造方法，在创建对象的同时，在构造方法中给对象赋值。</li>
<li>构造注入使用<code>&lt;constructor-arg&gt;</code>标签</li>
<li><constructor-arg>标签：一个 <constructor-arg>表示构造方法的一个参数</constructor-arg></constructor-arg></li>
<li><constructor-arg>标签属性：<ul>
<li>name：表示构造方法的形参名</li>
<li>index：表示构造方法的位置，参数从左往右位置是 0 ， 1， 2 的顺序</li>
<li><strong>value</strong>：如果构造方法的形参类型是简单类型，使用 value</li>
<li><strong>ref</strong>：如果构造方法的形参类型是引用类型的，使用 ref</li>
</ul>
</constructor-arg></li>
</ul>
<p>实例：</p>
<blockquote>
<p>一、创建实体类</p>
</blockquote>
<pre><code class="java">public class School{
  private String name;
  private String address;
  //setter
  //toString
}</code></pre>
<pre><code class="java">public class Student{
  private String name;
  private int age;
  private School school;
  public Student(){}
  public Student(String name,int age,School school){
    this.name = name;
    this.age = age;
    this.school = school;
  }
  //setter and getter
  //toString
}</code></pre>
<blockquote>
<p>二、创建 Spring-config的 XML 文件 applicationcontext.xml</p>
</blockquote>
<p><strong>1）使用 name 属性实现构造注入</strong></p>
<pre><code class="xml">&lt;!--使用 name 属性实现构造注入--&gt;
&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba03.Student&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;赵六&quot; /&gt;
  &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot; /&gt;
  &lt;constructor-arg name=&quot;school&quot; ref=&quot;MySchool&quot; /&gt;
&lt;/bean&gt;
&lt;bean id=&quot;MySchool&quot; class=&quot;com.bjpowernode.ba03.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
  &lt;property name=&quot;address&quot; value=&quot;北京&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p><strong>2)使用 index 属性实现构造注入</strong></p>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba03.Student&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;赵六&quot; /&gt;
  &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot; /&gt;
  &lt;constructor-arg index=&quot;2&quot; ref=&quot;MySchool&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p><strong>3)省略 index，默认顺序 0，1，2….</strong></p>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba03.Student&quot;&gt;
    &lt;constructor-arg value=&quot;赵六&quot; /&gt;
  &lt;constructor-arg value=&quot;20&quot; /&gt;
  &lt;constructor-arg ref=&quot;MySchool&quot; /&gt;
&lt;/bean&gt;
&lt;!--创建 File 类，使用构造注入--&gt;
&lt;bean id=&quot;myfile&quot; class=&quot;java.io.File&quot;&gt;
    &lt;constructor-arg name=&quot;parent&quot; value=&quot;Users/shixiang/course-SSM/Spring/ch01-hello-spring&quot; /&gt;
  &lt;constructor-arg name=&quot;child&quot; value=&quot;readme.txt&quot;&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>三、创建测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test04(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  Student student = (Student)ac.getBean(&quot;MyStudent&quot;);
  File file = (File)ac.getBean(&quot;myfile&quot;);
  System.out.println(student + file);
}</code></pre>
<hr>
<h4 id="3-引用类型的自动注入"><a href="#3-引用类型的自动注入" class="headerlink" title="3.引用类型的自动注入"></a>3.引用类型的自动注入</h4><ul>
<li>引用类型的自动注入：spring 框架根据某些规则可以给引用类型赋值。不用你再给引用类型赋值了</li>
<li>使用规则常用的是：<code>byName, byType</code></li>
</ul>
<h5 id="1-byName"><a href="#1-byName" class="headerlink" title="1.byName"></a>1.byName</h5><p><strong>byName</strong>(按名称注入)：java 类中<strong>引用类型</strong>的<strong>属性名</strong>和 spring 容器中（配置文件）<strong><bean>的id名称</bean></strong> 一样，</p>
<p>且数据类型是一致的，这样的容器中的 bean，spring 能够赋值给引用类型。</p>
<p>语法：</p>
<pre><code class="xml">&lt;bean id=&quot;xxx&quot; class=&quot;yyy&quot; autowire=&quot;byName&quot;&gt;
    简单类型属性赋值
&lt;/bean&gt;</code></pre>
<p>实例：</p>
<blockquote>
<p>一、创建实体类</p>
</blockquote>
<pre><code class="java">public class School{
  private String name;
  private String address;
  //setter
  //toString
}</code></pre>
<pre><code class="java">public class Student{
  private String name;
  private int age;
  private School school;
  public Student(){}
  public Student(String name,int age,School school){
    this.name = name;
    this.age = age;
    this.school = school;
  }
  //setter and getter
  //toString
}</code></pre>
<blockquote>
<p>二、创建 Spring-config 配置文件 applicationcontext.xml</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba04.Student&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot; /&gt;
  &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;
&lt;/bean&gt;
&lt;!--Student 类中的 School类型的属性名是 school，这里需要和 bean的 id 一致（byName 方式）--&gt;
&lt;bean id=&quot;school&quot; class=&quot;com.bjpowernode.ba04.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;深圳大学&quot; /&gt;
  &lt;property name=&quot;address&quot; value=&quot;深圳&quot; /&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>三、创建测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test05{
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  Student student = (Student)ac.getBean(&quot;MyStudent&quot;);
  System.out.println(student);
}</code></pre>
<h5 id="2-byType"><a href="#2-byType" class="headerlink" title="2.byType"></a>2.byType</h5><p><strong>byType</strong>（按类型注入）：java 类中引用类型的数据类型和 spring 容器中（配置文件）<bean>的 class 属性是同源关系的，这样的 bean 能够赋值给引用类型</bean></p>
<p><code>同源</code>：就是一类的意思</p>
<ul>
<li>java 类中引用类型的数据类型和 bean 的 class 的值是一样的</li>
<li>java 类中引用类型的数据类型和 bean 的 class 的值是父子类关系的</li>
<li>java 类中引用类型的数据类型和 bean 的 class 的值是接口和实现类关系的</li>
</ul>
<p><code>语法</code></p>
<pre><code class="xml">&lt;bean id=&quot;xxx&quot; class=&quot;yyy&quot; autowire=&quot;byType&quot;&gt;
    简单类型属性赋值
&lt;/bean&gt;</code></pre>
<p>实例：</p>
<blockquote>
<p>一、创建实体类</p>
</blockquote>
<pre><code class="java">public class School{
  private String name;
  private String address;
  //setter
  //toString
}</code></pre>
<pre><code class="java">public class Student{
  private String name;
  private int age;
  private School school;
  public Student(){}
  public Student(String name,int age,School school){
    this.name = name;
    this.age = age;
    this.school = school;
  }
  //setter and getter
  //toString
}</code></pre>
<pre><code class="java">//创建 School 的子类
public class PrimarySchool extends School{
  //继承父类的属性
}</code></pre>
<blockquote>
<p>二、创建 Spring-context 配置文件 applicationcontext.xml</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba05.Student&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot; /&gt;
  &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
&lt;/bean&gt;
&lt;!--声明 School 的子类--&gt;
&lt;bean id=&quot;primarySchool&quot; class=&quot;com.bjpowernode.ba05.PrimarySchool&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;深圳小学&quot; /&gt;
  &lt;property name=&quot;address&quot; value=&quot;深圳&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p><strong>注意</strong>：<code>在 byType 中，在 xml 配置文件中声明的 bean 只能有一个符合条件的，多余一个是错误的。</code></p>
<blockquote>
<p>三、创建测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test06(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  Student student = (Student)ac.getBean(&quot;MyStudent&quot;);
  System.out.println(student);
}</code></pre>
<hr>
<h2 id="三、为应用指定多个-Spring-配置文件"><a href="#三、为应用指定多个-Spring-配置文件" class="headerlink" title="三、为应用指定多个 Spring 配置文件"></a>三、为应用指定多个 Spring 配置文件</h2><ul>
<li><p>多个配置文件优势</p>
<ul>
<li><p>多个文件的大小比一个文件要小很多，效率高</p>
</li>
<li><p>避免多人竞争带来的冲突</p>
<ul>
<li>如果你的项目有多个模块（相关的功能在一起），一个模块一个配置文件<ul>
<li>学生考勤模块一个配置文件，张三写</li>
<li>学生成绩一个配置文件，李四写</li>
</ul>
</li>
<li>多文件的分配方式<ul>
<li>按功能模块，一个模块一个配置文件</li>
<li>按类的功能，数据库相关的配置一个配置文件，做事务的功能一个配置文件，做 service 功能的一个配置文件等。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>eg：</p>
<blockquote>
<p>1.School 模块的所有 bean 的声明，School 模块的配置文件</p>
<p>spring-school.xml</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;mySchool&quot; class=&quot;com.bjpowernode.ba06.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;广州大学&quot; /&gt;
  &lt;property name=&quot;address&quot; value=&quot;广州&quot; /&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>2.Student 模块所有 bean 的声明</p>
<p>spring-student.xml</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;MyStudent&quot; class=&quot;com.bjpowernode.ba06.Student&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot; /&gt;
  &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>3.创建主配置文件</p>
<p>total.xml</p>
</blockquote>
<pre><code class="xml">&lt;!--加载的是文件列表--&gt;
&lt;import resource=&quot;classpath:ba06/spring-*.xml&quot; /&gt;
&lt;!--
    在包含关系的配置文件中，可以使用通配符(*表示任意字符)
    注意：主的配置文件名称不能包含在通配符的范围，不能叫 spring-total.xml
--&gt;</code></pre>
<p><strong>包含关系的配置文件：</strong></p>
<ul>
<li><p>total 表示主配置文件：包含其它的配置文件的，主配置文件一般是不定义对象的。</p>
</li>
<li><p>语法：<code>&lt;import resource=&quot;classpath:其它配置文件的路径” /&gt;</code></p>
</li>
<li><p>关键字：”<code>classpath:</code>“表示类路径（class 文件所在的目录，target 目录下的 classes）在 spring 的配置文件中要指定其它文件的位置需要使用 classpath，告诉 spring 到哪去加载读取文件</p>
</li>
</ul>
<hr>
<h2 id="四、JDK-动态代理"><a href="#四、JDK-动态代理" class="headerlink" title="四、JDK 动态代理"></a>四、JDK 动态代理</h2><h3 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h3><p>动态代理： 可以在程序的执行过程中，创建代理对象。<br>通过代理对象执行方法，给目标类的方法增加额外的功能（功能增强）</p>
<h4 id="jdk动态代理实现步骤"><a href="#jdk动态代理实现步骤" class="headerlink" title="jdk动态代理实现步骤"></a>jdk动态代理实现步骤</h4><p>1.创建目标类，SomeServiceImpl目标类，给它的doSome，doOther增加 输出时间，事务。</p>
<p>2.创建InvocationHandler接口的实现类，在这个类中实现给目标的方法增加功能</p>
<p>3.使用jdk中 在Proxy，创建对象。实现创建对象的能力</p>
<p>实例：</p>
<blockquote>
<p>一、创建目标接口</p>
</blockquote>
<pre><code class="java">public interface SomeService{
  doSome();
  doOther();
}</code></pre>
<blockquote>
<p>二、创建目标接口实现类</p>
</blockquote>
<pre><code class="java">public class SomeServiceImpl implements{
  public void doSome(){
    System.out.println(&quot;执行业务方法doSome()&quot;);
  }
}</code></pre>
<blockquote>
<p>三、创建代理InvocationHandler 接口实现类</p>
</blockquote>
<pre><code class="java">public class MyInvocationHandler implements InvocationHandler{
  // 目标对象
  private Object target; //SomeServiceImpl
  public MyInvocationHandler(Object target){
    this.target = target;
  }
  public Object invoke(Object proxy,Method method,Object[] args)throws Throwable{
    //通过代理对象执行方法时，会执行这个 invoke 方法
    Object result;
    result = method.invoke(target,args);
    //在目标方法执行之后，提交事务
    System.out.println(&quot;提交事务&quot;);
  }
}</code></pre>
<blockquote>
<p>四、创建测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test(){
  //创建目标对象
  SomeService target = new SomeServiceImpl();
  //创建 InvocationHandler 对象
  InvocationHandler handler = new MyInvocationHandler(targer);
  //使用 Proxy 代理
  //返回的是一个接口
  SomeService proxy = (SomeService)Proxy.newProxyInstance(
      target.getClass().getClassLoader(),        //获取目标类的类加载器
    target.getClass().getInterfaces(),        //获取目标类实现的接口
    handler                                                                //第三个参数是代理对象要执行的功能是写在了 InvocationHandler 中
  );
  //通过代理执行方法，会调用 handler 中的 invoke()
  proxy.doSome();
}</code></pre>
<hr>
<h2 id="五、基于注解的-DI"><a href="#五、基于注解的-DI" class="headerlink" title="五、基于注解的 DI"></a>五、基于注解的 DI</h2><h3 id="一、使用注解的步骤："><a href="#一、使用注解的步骤：" class="headerlink" title="一、使用注解的步骤："></a>一、使用注解的步骤：</h3><ol>
<li><p>加入 maven的依赖spring-context，在你加入 spring-context的同时，间接加入 spring-aop 的依赖。</p>
<p>使用注解必须使用spring-aop</p>
</li>
<li><p>在类中加入Spring 的注解（多个不同功能的注解）</p>
</li>
<li><p>在 spring的配置文件中，加入组件扫描器标签，说明注解在你的项目中的位置</p>
</li>
</ol>
<blockquote>
<ul>
<li>对于DI 使用注解，将不再需要在 Spring 配置文件中声明 bean 实例。Spring 中使用注解，需要在原有 Spring 运行环境基础上再做一些改变。</li>
<li>需要在 Spring配置文件中配置<code>组件扫描器</code>，用于在指定的基本包中扫描注解</li>
</ul>
</blockquote>
<h4 id="声明组件扫描器（component-scan）"><a href="#声明组件扫描器（component-scan）" class="headerlink" title="声明组件扫描器（component-scan）"></a>声明组件扫描器（component-scan）</h4><ul>
<li>component<ul>
<li>组件，指的就是 java 对象</li>
</ul>
</li>
<li>scan<ul>
<li>scanner 扫描，扫描器</li>
</ul>
</li>
<li>base-package<ul>
<li>指定注解在你的项目中的包名</li>
</ul>
</li>
<li>component-scan 工作方式<ul>
<li>spring 会扫描编译 base-package 指定的包，把包中和子包中的所有类，然后找到类中的注解，按照注解的功能创建对象，或给属性赋值。</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.bjpowernode.ba01&quot; /&gt;</code></pre>
<h5 id="指定多个包的三种方式"><a href="#指定多个包的三种方式" class="headerlink" title="指定多个包的三种方式"></a>指定多个包的三种方式</h5><h6 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h6><p>使用多个组件扫描器，指定不同的包</p>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.bjpowernode.ba01&quot; /&gt;
&lt;context:component-scan base-package=&quot;com.bjpowernode.ba02&quot; /&gt;</code></pre>
<h6 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h6><p>使用分隔符(; 或 ,)分隔多个包名</p>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.bjpowernode.ba01;com.bjpowernode.ba02&quot; /&gt;</code></pre>
<h6 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h6><p>指定父包</p>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.bjpowernode&quot; &gt;</code></pre>
<h5 id="加载属性配置文件"><a href="#加载属性配置文件" class="headerlink" title="加载属性配置文件"></a>加载属性配置文件</h5><p>resources/test.properties</p>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:test.properties&quot; /&gt;</code></pre>
<h3 id="二、学习的注解"><a href="#二、学习的注解" class="headerlink" title="二、学习的注解"></a>二、学习的注解</h3><ul>
<li>@Component</li>
<li>@Repository</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Value</li>
<li>@Autowired</li>
<li>@Resource</li>
</ul>
<h4 id="一、定义-Bean-的注解-Component"><a href="#一、定义-Bean-的注解-Component" class="headerlink" title="一、定义 Bean 的注解@Component"></a>一、定义 Bean 的注解@Component</h4><p>需要在类上使用注解<code>@Component</code>，该注解的 value 属性用于指定该 bean 的 id 值</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p><strong>@Component</strong>:创建对象的，等同于<bean>的功能</bean></p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><strong>value</strong>就是对象的名称，也就是 bean 的 id 值，value 的值是唯一的，创建的对象在整个 spring 容器中就一个</p>
<h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><p>在类的上面</p>
<blockquote>
<p>@Component(value=”myStudent”)    等同于</p>
<pre><code class="xml">&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.ba01.Student&quot; /&gt;</code></pre>
</blockquote>
<p>例：</p>
<blockquote>
<p>创建 Student 实体类</p>
<p>1.使用 value 属性，指定对象的名称</p>
</blockquote>
<pre><code class="java">@Component(value=&quot;myStudent&quot;)
public class Student{
    private String name;
    private Integer age;
  //setter and getter
  //constructor
  //toString
}</code></pre>
<blockquote>
<p>2.可以省略 value</p>
</blockquote>
<pre><code class="java">@Component(&quot;myStudent&quot;)
public class Student{
    private String name;
    private Integer age;
  //setter and getter
  //constructor
  //toString
}</code></pre>
<blockquote>
<p>3.不指定对象的名称，由 Spring 提供默认名称：<code>类名的首字母小写</code></p>
</blockquote>
<pre><code class="java">@Component
public class Student{
    private String name;
    private Integer age;
  //setter and getter
  //constructor
  //toString
}

//测试类
@Test
public void test(){
    String config = &quot;applicationContext.xml&quot;;
    ApplicationContext ac = new ClassPathXmlApplicationContext(config);
    //@Component不指定 value 属性，bean 的 id 默认是类名的首字母小写
    Student student = (Student)ac.getBean(&quot;student&quot;); 
    System.out.println(student.toString());
}</code></pre>
<h4 id="二、-Repository、-Service、-Controller"><a href="#二、-Repository、-Service、-Controller" class="headerlink" title="二、@Repository、@Service、@Controller"></a>二、@Repository、@Service、@Controller</h4><p>和@Component 功能一样，这几个注解都是用于创建对象的</p>
<h5 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h5><ul>
<li>用于<code>持久层</code>类的上面的</li>
<li>放在 dao 的实现类上面，表示创建 dao 对象，dao 对象是能<strong>访问数据库的</strong></li>
</ul>
<h5 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h5><ul>
<li>用在<code>业务层</code>类的上面的</li>
<li>放在 service 的实现类上面，创建 service 对象，service 对象是做业务处理的，可以有事务等功能的</li>
</ul>
<h5 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h5><ul>
<li>用在<code>控制层</code>的上面的</li>
<li>放在控制器（处理器）类的上面，创建控制器对象的，控制器对象，能够接受用户提交的参数，显示请求的处理结果</li>
</ul>
<blockquote>
<p>以上三个注解的使用语法和@Component 一样的，都能创建对象，但是这三个注解还有额外的功能</p>
<p>@Repository，@Service，@Controller是给项目的对象分层的</p>
</blockquote>
<h4 id="三、-Value"><a href="#三、-Value" class="headerlink" title="三、@Value"></a>三、@Value</h4><h5 id="简单类型属性注入"><a href="#简单类型属性注入" class="headerlink" title="简单类型属性注入"></a>简单类型属性注入</h5><ul>
<li>需要在属性上使用注解@Value，该注解的 value 属性用于指定要注入的值</li>
<li>使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上</li>
</ul>
<h6 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h6><p>简单类型的属性赋值</p>
<h6 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h6><p>value 是 <code>String</code> 类型的，表示简单类型的属性值</p>
<h6 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h6><ul>
<li>1.在属性定义的上面，无需 setter，推荐使用</li>
<li>2.在 setter 上面</li>
</ul>
<p>例</p>
<blockquote>
<p>1.使用 value 属性</p>
</blockquote>
<pre><code class="java">@Component
public class Student{
    @Value(value=&quot;张三&quot;)
    private String name;
    private Integer age;
    //定义在 setter 上面
    @Value(value=&quot;20&quot;)
    public void setAge(Integer age){
         this.age = age;
    }
}</code></pre>
<blockquote>
<p>2.省略 value</p>
</blockquote>
<pre><code class="java">@Component
public class Student{
    @Value(&quot;张三&quot;)
    private String name;
    @Value(&quot;20&quot;)
    private Integer age;
}</code></pre>
<blockquote>
<p>3.使用属性配置文件，用<code>${}</code>注入</p>
<ul>
<li>1、先创建属性配置文件test.properties</li>
</ul>
</blockquote>
<pre><code class="properties">myname=zhangsan
myage=20</code></pre>
<blockquote>
<ul>
<li>2、applicationcontext.xml 文件中加载属性配置文件</li>
</ul>
</blockquote>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:test.properties&quot; /&gt;</code></pre>
<p>例：</p>
<pre><code class="java">@Component
public class Student{
    @Value(&quot;${myname}&quot;)
    private String name;
    @Value(&quot;${myage}&quot;)
    private Integer age;
}</code></pre>
<h4 id="四、引用类型属性注入"><a href="#四、引用类型属性注入" class="headerlink" title="四、引用类型属性注入"></a>四、引用类型属性注入</h4><h5 id="一、-Autowired"><a href="#一、-Autowired" class="headerlink" title="一、@Autowired"></a>一、@Autowired</h5><h6 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h6><ul>
<li>引用类型注入</li>
<li>spring 框架提供的注解，实现引用类型的赋值</li>
<li>spring 中通过注解给引用类型赋值，使用的是自动注入原理，支持 byName，byType</li>
<li>默认使用的是 byType 自动注入</li>
</ul>
<h6 id="位置-2"><a href="#位置-2" class="headerlink" title="位置"></a>位置</h6><ul>
<li>1.在属性定义的上面，无需 setter方法，推荐使用</li>
<li>2.在 setter方法 上面</li>
</ul>
<h6 id="1、byType-自动注入-Autowired"><a href="#1、byType-自动注入-Autowired" class="headerlink" title="1、byType 自动注入@Autowired"></a>1、byType 自动注入@Autowired</h6><ul>
<li>需要在引用属性上使用注解@Autowired，该注解默认使用按类型自动装配 Bean的方式。</li>
<li>使用该注解完成属性注入时，类中无需 setter，当然，若属性有 setter，则也可将其加到 setter 上</li>
</ul>
<p>例：</p>
<blockquote>
<p>1.创建实体类 School</p>
</blockquote>
<pre><code class="java">@Component(&quot;mySchool&quot;)
public class School{
    @Value(&quot;清华大学&quot;)
    private String name;
    @Value(&quot;北京&quot;)
    private String address;
}</code></pre>
<blockquote>
<p>2.创建实体类Student,使用@Autowired自动注入赋值</p>
</blockquote>
<pre><code class="java">@Component(&quot;myStudent&quot;)
public class Student{
    @Value(&quot;赵六&quot;)
    private String name;
    @Value(&quot;20&quot;)
    private Integer age;
    @Autowired
    private School school;
}</code></pre>
<h6 id="2、byName自动注入-Autowired与-Qualifier"><a href="#2、byName自动注入-Autowired与-Qualifier" class="headerlink" title="2、byName自动注入 / @Autowired与@Qualifier"></a>2、byName自动注入 / @Autowired与@Qualifier</h6><ul>
<li>需要在引用属性上联合使用注解<code>@Autowird</code>与<code>@Qualifier</code>。</li>
<li><code>@Qualifier</code>的 value 属性用于指定要匹配的 Bean 的 id 值。</li>
<li>类中无需 setter方法，也可加到 setter 方法上</li>
</ul>
<p><strong>如果要使用 baName 方式，需要做的是</strong> </p>
<ul>
<li>在属性的上面加入@Autowired</li>
<li>需要在属性的上面加入@Qualifier(value = “bean的 id 值”)，表示使用指定名称的 bean 完成赋值</li>
</ul>
<p>例：</p>
<blockquote>
<p>1.创建实体类 School</p>
</blockquote>
<pre><code class="java">@Component(&quot;mySchool&quot;)
public class School{
    @Value(&quot;清华大学&quot;)
    private String name;
    @Value(&quot;北京&quot;)
    private String address;
}</code></pre>
<blockquote>
<p>2.创建实体类 Student，使用 byName 自动注入</p>
</blockquote>
<pre><code class="java">@Component(&quot;myStudent&quot;)
public class Student{
    @Value(&quot;赵六&quot;)
    private String name;
    @Value(&quot;20&quot;)
    private Integer age;

    @Autowired
    @Qualifier(&quot;mySchool&quot;) //value 可以省略  @Qualifier(value = &quot;mySchool&quot;)
    private School school;
}</code></pre>
<h5 id="二、-Resource"><a href="#二、-Resource" class="headerlink" title="二、@Resource"></a>二、@Resource</h5><ul>
<li>Spring 提供了对 jdk 中@Resource注解的支持</li>
<li>@Resource注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。</li>
<li>默认是按名称注入</li>
<li>使用该注解，要求 JDK 必须是6及以上版本</li>
<li>@Resource可用在属性上，也可以用在 setter 上</li>
</ul>
<h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><ul>
<li>@Resource 是来自 JDK 中的注解，spring 框架提供了对这个注解的功能支持，可以使用它给引用类型赋值</li>
<li>使用的也是自动注入原理，支持 byName，byType，<code>默认是 byName</code></li>
</ul>
<h5 id="位置-3"><a href="#位置-3" class="headerlink" title="位置"></a>位置</h5><ul>
<li>1、在属性定义的上面。无需使用 setter，推荐使用</li>
<li>2、在 setter 方法上面</li>
</ul>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>默认是 <strong>byName</strong>，找的是<strong>类名的首字母小写的对象</strong>：先使用 byName 自动注入，如果 byName 赋值失败，再使用 byType</p>
<p>例：</p>
<pre><code class="java">@Component(&quot;mySchool&quot;)
public class School{
    @Value(&quot;清华大学&quot;)
    private String name;
    @Value(&quot;北京&quot;)
    private String address;
}</code></pre>
<pre><code class="java">@Component(&quot;myStudent&quot;)
public class Student{
    @Value(&quot;赵六&quot;)
    private String name;
    @Value(&quot;20&quot;)
    private Integer age;

    @Resource
    private School school;
}</code></pre>
<hr>
<h2 id="六、注解与-XML-的对比"><a href="#六、注解与-XML-的对比" class="headerlink" title="六、注解与 XML 的对比"></a>六、注解与 XML 的对比</h2><h3 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h3><h4 id="注解的优点"><a href="#注解的优点" class="headerlink" title="注解的优点"></a>注解的优点</h4><ul>
<li>方便</li>
<li>直观</li>
<li>高效（代码少，没有配置文件的书写 那么复杂）</li>
</ul>
<h4 id="注解的弊端"><a href="#注解的弊端" class="headerlink" title="注解的弊端"></a>注解的弊端</h4><p>其弊端也显而易见：以硬编码的方式写入到 Java 中，修改是需要重新编译代码的。</p>
<h3 id="二、XML"><a href="#二、XML" class="headerlink" title="二、XML"></a>二、XML</h3><h4 id="XML-方式优点"><a href="#XML-方式优点" class="headerlink" title="XML 方式优点"></a>XML 方式优点</h4><ul>
<li>配置和代码是分离的</li>
<li>在 XML 中修改，无需编译代码，只需要重启服务器即可将新的配置加载</li>
</ul>
<h4 id="XML-方式缺点"><a href="#XML-方式缺点" class="headerlink" title="XML 方式缺点"></a>XML 方式缺点</h4><ul>
<li>编写麻烦</li>
<li>效率太低</li>
<li>大型项目过于复杂。</li>
</ul>
<hr>
<h2 id="七、AOP"><a href="#七、AOP" class="headerlink" title="七、AOP"></a>七、AOP</h2><h3 id="一、AOP-简介"><a href="#一、AOP-简介" class="headerlink" title="一、AOP 简介"></a>一、AOP 简介</h3><ul>
<li>面向切面编程，基于动态代理的，可以使用 <code>JDK</code>，<code>CGLIB</code> 两种代理方式</li>
<li>AOP 就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了，让开发人员用一种统一的方式，使用动态代理。</li>
</ul>
<blockquote>
<p><strong>AOP（Aspect Orient Programming）</strong>:面向切面编程</p>
<ul>
<li>Aspect：切面，给你的目标类增加的功能，就是切面，像上面用的日志、事务都是切面<ul>
<li><strong>切面的特点</strong>:一般都是非业务方法，可以独立使用</li>
</ul>
</li>
<li>Orient:面向，对着</li>
<li>Programming:编程</li>
</ul>
</blockquote>
<h4 id="怎么理解面向切面编程？"><a href="#怎么理解面向切面编程？" class="headerlink" title="怎么理解面向切面编程？"></a>怎么理解面向切面编程？</h4><ul>
<li>1、需要在分析项目时，找出切面</li>
<li>2、合理的安排切面的执行时间（在目标方法前，还是目标方法后）</li>
<li>3、合理的安排切面执行的位置，在那个类，那个方法去增加功能</li>
</ul>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li><p><code>Aspect</code>:切面，表示增强功能，就是一堆代码，完成某一个功能。非业务功能，常见的切面功能有日志，事务，统计信息，参数检查，权                 限验证</p>
</li>
<li><p><code>JoinPoint</code>：连接点，链接业务方法和切面的位置。就是某个类中的业务方法</p>
</li>
<li><p><code>Pointcut</code>：切入点，指多个连接点方法的集合，多个方法</p>
</li>
<li><p><code>Advice</code>：通知，通知表示切面功能执行的时间。</p>
</li>
</ul>
<h4 id="切面有三个关键的要素"><a href="#切面有三个关键的要素" class="headerlink" title="切面有三个关键的要素"></a>切面有三个关键的要素</h4><ul>
<li>切面的功能代码，切面干什么</li>
<li>切面的执行位置，使用 <code>Pointcut</code>表示切面执行的位置</li>
<li>切面的执行时间，使用<code>Advice</code>表示时间，在目标方法之前，还是目标方法之后</li>
</ul>
<h3 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式:"></a>实现方式:</h4><ul>
<li><strong>JDK 动态代理</strong>:使用JDK中的 Proxy，Method，InvocationHandler创建代理对象，<code>JDK 动态代理要求目标类必须实现接口</code></li>
<li><strong>CGLIB 动态代理</strong>:第三方的工具库，创建代理对象，原理是继承。通过继承目标类，创建子类。<ul>
<li>子类就是代理对象，要求目标类不能是final的，方法也不能是final 的</li>
</ul>
</li>
</ul>
<h4 id="动态代理的作用"><a href="#动态代理的作用" class="headerlink" title="动态代理的作用"></a>动态代理的作用</h4><ul>
<li>在目标类源代码不改变的情况下，增强功能</li>
<li>减少代码的重复</li>
<li>专注业务逻辑代码</li>
<li>解耦合，让你的业务功能和日志、事务等非业务功能分离</li>
</ul>
<h3 id="三、AOP-的实现"><a href="#三、AOP-的实现" class="headerlink" title="三、AOP 的实现"></a>三、AOP 的实现</h3><p>AOP 是一个规范，是对动态代理的一个规范化，一个标准</p>
<h4 id="1、AOP-的技术实现框架"><a href="#1、AOP-的技术实现框架" class="headerlink" title="1、AOP 的技术实现框架"></a>1、AOP 的技术实现框架</h4><h5 id="一、Spring"><a href="#一、Spring" class="headerlink" title="一、Spring"></a>一、Spring</h5><ul>
<li>Spring 在内部实现了 AOP 规范，能做 AOP 的工作</li>
<li>Spring主要在事务处理时 AOP</li>
<li>我们项目开发中很少使用 Spring 的 AOP 实现。因为 Spring 的 AOP 笔记笨重。</li>
</ul>
<h5 id="二、aspectJ"><a href="#二、aspectJ" class="headerlink" title="二、aspectJ"></a>二、aspectJ</h5><ul>
<li>一个开源的专门做AOP的框架，Spring框架中集成了aspectJ框架，通过Spring就能使用aspectJ的功能</li>
<li>aspectJ框架实现 aop有两种方式：<ul>
<li>使用 xml的配置文件：配置全局事务</li>
<li>使用注解，我们在项目中要做aop 功能，一般都使用注解，aspectJ有 5 个注解。</li>
</ul>
</li>
</ul>
<h4 id="2、学习aspectJ框架的使用"><a href="#2、学习aspectJ框架的使用" class="headerlink" title="2、学习aspectJ框架的使用"></a>2、学习aspectJ框架的使用</h4><h5 id="1、使用-aspectJ-实现-AOP-的基本步骤"><a href="#1、使用-aspectJ-实现-AOP-的基本步骤" class="headerlink" title="1、使用 aspectJ 实现 AOP 的基本步骤"></a>1、使用 aspectJ 实现 AOP 的基本步骤</h5><ul>
<li><p>1、新建 maven 项目</p>
</li>
<li><p>2、加入依赖</p>
<ul>
<li>spring 依赖spring-context</li>
<li>aspectj 依赖spring-aspects</li>
<li>junit 单元测试</li>
</ul>
</li>
<li><p>3、创建目标类：接口和该接口的实现类</p>
<ul>
<li>要做的是给类中的方法增加功能</li>
</ul>
</li>
<li><p>4、创建切面类：普通类</p>
<ul>
<li>1、在类的上面加入<code>@Aspect</code>注解</li>
<li>2、在类中定义方法，方法就是切面要执行的功能代码<ul>
<li>在方法的上面加入 aspectj 的通知注解，例如<code>@Before</code></li>
<li>还需要指定切入点表达式<code>execution()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>5、创建spring的配置文件：声明对象，把对象交给容器统一管理</p>
<ul>
<li><p>声明对象可以使用<code>注解</code>或者xml 配置文件<code>&lt;bean&gt;</code></p>
<ul>
<li><p>1、声明目标对象</p>
<pre><code class="xml">&lt;bean id=&quot;someService&quot; class=&quot;com.bjpowernode.ba08.SomeServiceImpl&quot;/&gt;</code></pre>
</li>
<li><p>2、声明切面类对象</p>
<pre><code class="xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.bjpowernode.ba08.MyAspect&quot; /&gt;</code></pre>
</li>
<li><p>3、声明aspectj框架中的自动代理生成器标签</p>
<ul>
<li><code>自动代理生成器</code>：用来完成代理对象的自动创建功能的。</li>
</ul>
<pre><code class="xml">&lt;!--
    声明自动代理生成器：使用 aspectj 框架内部的功能，创建目标对象的代理对象。
创建代理对象是在内存中实现的，修改目标对象在内存中的结构。创建为代理对象
所以目标对象就是被修改后的代理对象
    aspectj-autoproxy：会把 spring 容器中的所有的目标对象，一次性都生成代理对象
--&gt;
&lt;aop:aspectj-autoproxy /&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6、创建测试类，从spring 容器中获取目标对象（实际上就是代理对象）通过代理执行方法，实现 aop的功能增强。</p>
</li>
</ul>
<h5 id="2、切面通知Advice"><a href="#2、切面通知Advice" class="headerlink" title="2、切面通知Advice"></a>2、切面通知Advice</h5><ul>
<li><p>切面的执行时间，这个执行时间在 规范中叫做通知Advice（通知，增强）</p>
</li>
<li><p>在aspectJ框架中使用注解表示的，也可以使用 xml 配置文件中的标签</p>
<ul>
<li><code>@Before=</code>：前置通知</li>
<li><code>@AfterReturning</code>：后置通知</li>
<li><code>@Around</code>：环绕通知</li>
<li><code>@AfterThrowing</code>：异常通知</li>
<li><code>@After</code>：最终通知</li>
</ul>
</li>
</ul>
<h5 id="3、切入点表达式"><a href="#3、切入点表达式" class="headerlink" title="3、切入点表达式"></a>3、切入点表达式</h5><p>表示切面执行的位置</p>
<p><code>原型</code></p>
<pre><code class="markdown">execution(modifiers-pattern? ret-type-pattern  declaring-type-pattern?name-pattern(param-pattern)throws-pattern?)</code></pre>
<ul>
<li><strong>modifiers-patter</strong> 访问权限类型</li>
<li><strong>ret-type-pattern</strong> 返回值类型</li>
<li><strong>declaring-type-pattern</strong> 包名类名</li>
<li><strong>name-pattern(param-pattern)</strong> 方法名（参数类型和参数个数）</li>
<li><strong>throws-pattern</strong> 抛出异常类型</li>
<li><strong>?</strong> 表示可选的部分</li>
</ul>
<p>共四个部分</p>
<p><code>execution</code></p>
<p>execution(访问权限 方法返回值  方法声明(参数) 异常)</p>
<ul>
<li><p>切入点表达式要匹配的对象就是目标方法的方法名。所以，execution表达式中明显就是方法的签名（Signature）。</p>
</li>
<li><p>注意：表达式中黑色文字表示可省略部分，各部分间用空格分开。在其中可以使用以下符号。</p>
<ul>
<li><code>*</code>    ：0至多个任意字符 </li>
<li><code>..</code> :用在方法参数中，表示任意多个参数，用在包名后，表示当前包及其子包路径</li>
<li><code>+</code>：用在类名后，表示当前类及其子类。用在接口后，表示当前接口及其实现类</li>
</ul>
</li>
<li><p>举例：</p>
<ul>
<li><strong>execution(public * *(..))</strong><ul>
<li>指定切入点为：任意公共方法</li>
</ul>
</li>
<li><strong>execution(* set*(..))</strong><ul>
<li>指定切入点为：任何一个以”set”开始的方法</li>
</ul>
</li>
<li><strong>execution(* com.xyz.service.<em>.\</em>(..))</strong><ul>
<li>指定切入点为：定义在 service 包里的任意类的任意方法</li>
</ul>
</li>
<li><strong>execution(<em>com.xyz.service..\</em>.*(..))</strong><ul>
<li>指定切入点为：定义在service包或者子包里任意方法。” .. “出现在类名中时，后面必须跟” * “，表示包、子包下的所有类。</li>
</ul>
</li>
<li><strong>execution(* <em>..service.\</em>.*(..))</strong><ul>
<li>指定所有包下的 service子包下所有类（接口）中所有方法为切入点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、AspectJ的开发环境"><a href="#3、AspectJ的开发环境" class="headerlink" title="3、AspectJ的开发环境"></a>3、AspectJ的开发环境</h4><ul>
<li>1、maven 依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>2、引入约束<ul>
<li>在AspectJ实现 AOP 时，要引入AOP的约束。配置文件中使用的 AOP约束中的标签，均是AspectJ框架使用的，而非Spring框架本身在实现AOP 时使用的。</li>
<li>AspectJ对于 AOP的实现有注解和配置文件两种方式，常用的是注解方式。</li>
</ul>
</li>
</ul>
<h4 id="4、AspectJ基于注解的-AOP-实现"><a href="#4、AspectJ基于注解的-AOP-实现" class="headerlink" title="4、AspectJ基于注解的 AOP 实现"></a>4、AspectJ基于注解的 AOP 实现</h4><p>AspectJ提供了以注解方式对与 AOP的实现</p>
<h5 id="一、实现步骤"><a href="#一、实现步骤" class="headerlink" title="一、实现步骤"></a>一、实现步骤</h5><p><strong>1、定义业务接口与实现类</strong> </p>
<pre><code class="java">public interface SomeService{
  void doSome(String name,int age);
}</code></pre>
<pre><code class="java">public class SomeServiceImpl implements SomeService{
  public void doSome(String name,int age){
    System.out.println(&quot;执行了业务方法 doSome()&quot;);
  }
}</code></pre>
<p><strong>2、定义切面类</strong> </p>
<ul>
<li>类中定义若干普通方法，将作为不同的通知方法，用来增强功能</li>
<li><code>@Aspect</code><ul>
<li>是aspectj框架中的注解</li>
<li>作用：表示当前类是切面类<ul>
<li>切面类：用来给业务方法增加功能的类，在这个类中有切面的功能代码</li>
</ul>
</li>
<li>位置：在类定义的上面</li>
<li><code>@Before</code><ul>
<li><strong>前置通知注解</strong></li>
<li><strong>属性</strong>：value，是切入点表达式，表示切面的功能执行的位置</li>
<li><strong>位置</strong>：在方法的上面</li>
<li>特点<ol>
<li>在目标方法之前先执行的</li>
<li>不会改变目标方法的执行结果</li>
<li>不会影响目标方法的执行</li>
</ol>
</li>
</ul>
</li>
<li>前置通知方法定义，方法是实现切面功能的<ul>
<li>方法的定义要求：<ul>
<li>公共方法 public</li>
<li>方法没有返回值</li>
<li>方法的名称自定义</li>
<li>方法可以有参数，也可以没有参数。如果有参数，参数不是自定义的，有几个参数类型可以使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">/*
 *    @Aspect : 是aspectj框架的注解，表示当前类是切面类
 */
@Aspect
public class MyAspect{
  /*
   *    @Before:前置通知
   *        属性：value    切入点表达式，表示切面执行的位置
   *        位置：方法的定义上面
   */
  @Before(value=&quot;execution(* com.bjpowernode.ba01.SomeServiceImpl.doSome(..))&quot;)
  public void myBefore(){
    //就是切面代码的功能，例如日志的输出，事务的处理
    System.out.println(&quot;前置通知：在目标方法之前先执行，例如输出日志&quot;);
  }
}</code></pre>
<p><strong>3、声明目标对象切面类对象</strong> </p>
<p>可以使用 XML 配置 bean 或者注解的方式</p>
<pre><code class="xml">&lt;!--把对象交到spring 容器，由spring容器统一创建，管理对象--&gt;
&lt;!--声明目标类对象--&gt;
&lt;bean id=&quot;someServiceTarget&quot; class=&quot;com.bjpowernode.ba01.SomeServiceImpl&quot; /&gt;    
&lt;!--声明切面类对象--&gt;
&lt;bean id=&quot;myAspect&quot; class=&quot;com.bjpowernode.ba01.MyAspect&quot; /&gt;</code></pre>
<p><strong>4、注册 AspectJ的 自动代理</strong> </p>
<p>在定义好切面Aspect后，需要通知 Spring容器，让容器生成“目标类+切面”的代理对象。这个代理是由容器自动生成的。只需要在Spring配置文件中注册一个基于aspectj的<code>自动代理生成器&lt;aop:aspectj-autoproxy /&gt;</code>，其就会自动扫描到<code>@Aspect</code> 注解，并按通知类型与切入点，将其注入，并生成代理。</p>
<pre><code class="xml">&lt;!--
    声明自动代理生成器：使用aspectj框架内部的功能。创建目标对象的代理对象。
    创建代理对象是在内存中实现的，修改目标对象在内存中的结构。创建为代理对象
    所以目标对象就是被修改后的代理对象
    aspectj-autoproxy：会把spring容器中的所有的目标对象，一次性都生成代理对象
--&gt;
&lt;aop:aspectj-autoproxy /&gt;</code></pre>
<blockquote>
<ul>
<li><a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>的底层是由 AnnotationAwareAspectJAutoProxyCreator 实现的。</li>
<li>从其类名就可看出，是基于AspectJ的注解适配自动代理生成器。</li>
<li>其工作原理是：<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>通过扫描找到@Aspect定义的切面类，再由切面类根据切入点找到目标类的目标方法，再由通知类型找到切入的时间点</li>
</ul>
</blockquote>
<p><strong>5、测试类中使用目标对象的id</strong> </p>
<pre><code class="java">@Test
public void test01(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  //从spring容器中获取目标对象，目标就是经过aspectj修改后的代理对象
  SomeService proxy = (SomeService)ac.getBean(&quot;someServiceTarget&quot;);
  //com.sun.proxy.$Proxy6: 目标对象有接口使用jdk动态代理
  //System.out.println(&quot;proxy:&quot; + proxy.getClass().getName());
  //通过代理执行业务方法，实现功能增强
  proxy.doSome(&quot;zs&quot;,20);
}</code></pre>
<h5 id="二、-Before前置通知"><a href="#二、-Before前置通知" class="headerlink" title="二、@Before前置通知"></a>二、@Before前置通知</h5><p><strong>@Before前置通知-方法有<code>JoinPoint</code>参数</strong></p>
<ul>
<li>在目标方法执行之前执行。被注解为前置通知的方法，可以包含一个<code>JoinPoint</code>类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取<strong>切入点表达式</strong>、<strong>方法签名</strong>、<strong>目标对象</strong>等</li>
<li>不光前置通知的方法，可以包含一个<code>JoinPoint</code>类型参数，所有的通知方法均可包含该参数</li>
<li>指定通知方法中的参数：<code>JoinPoint</code></li>
</ul>
<p><strong><code>JoinPoint</code></strong></p>
<ul>
<li>业务方法，要加入切面功能的业务方法<ul>
<li>作用是：可以在通知方法中获取方法执行时的信息，例如方法名称，方法的实参</li>
<li>如果你的切面功能中需要用到方法的信息，就加入 JoinPoint</li>
<li>这个JoinPoint参数的值是由框架赋予，必须是第一个位置的参数</li>
<li>getSignature()：获取连接点的方法签名（定义）</li>
<li>getArgs:  获取连接点的方法参数信息</li>
</ul>
</li>
</ul>
<pre><code class="java">/**
 *    通知方法：使用了通知注解修饰的方法。
 *    通知方法可以有参数，但是参数不是任意的
 *    1.JoinPoint：表示连接点方法
 */
@Before(value=&quot;execution(* *..SomeServiceImpl.do*(..))&quot;)
public void myBefore2(JoinPoint jp){
  //JoinPoint能够获取到方法的定义，方法的参数等信息
  System.out.println(&quot;连接点的方法定义：&quot; + jp.getSignature());
  System.out.println(&quot;连接点方法的参数个数：&quot; + jp.getArgs().length);
  //方法参数的信息
  Object[] args = jp.getArgs();
  for(Object arg:args){
    System.out.println(&quot;参数=&quot; + arg);
  }
  //就是你切面要执行的功能，例如日志的输出、事务的处理
  System.out.println(&quot;前置功能：在目标方法之前先执行，例如输出日志&quot;);
}</code></pre>
<h5 id="三、-AfterReturning后置通知"><a href="#三、-AfterReturning后置通知" class="headerlink" title="三、@AfterReturning后置通知"></a>三、@AfterReturning后置通知</h5><p><strong>@AfterReturning后置通知-注解有<code>returning</code>属性</strong> </p>
<ul>
<li><p>在目标方法执行之后执行。由于是目标方法之后执行，所以可以获取到目标方法的返回值。该注解的<code>returing</code>属性就是用于指定接收方法返回值的变量名。所以，被注解为后置通知的方法，除了可以包含<code>JoinPoint</code>参数外，还可以包含用于接收返回值的变量。该变量最好为<code>Object</code>类型，因为目标方法的返回值可能是任何类型。</p>
</li>
<li><p>后置通知定义方法，方法是实现切面功能的</p>
</li>
</ul>
<p><strong><code>方法的定义要求</code></strong></p>
<ul>
<li>公共方法    public</li>
<li>方法没有返回值</li>
<li>方法的名称自定义</li>
<li><code>方法有参数，推荐是 Object，参数名自定义</code></li>
</ul>
<p><strong><code>@AfterReturning</code></strong></p>
<ul>
<li>后置通知</li>
<li>属性<ul>
<li>value    切入点表达式</li>
<li>returning  自定义的变量，表示目标方法的返回值的自定义变量名必须和通知方法的形参名是一样的</li>
</ul>
</li>
<li>位置<ul>
<li>在方法定义的上面</li>
</ul>
</li>
<li>特点<ul>
<li>在目标方法之后执行的</li>
<li>能够获取到目标方法的返回值，可以根据这个返回值做不同的处理功能<ul>
<li>Object    res = doOther();</li>
</ul>
</li>
<li>可以修改这个返回值</li>
</ul>
</li>
</ul>
<p><strong><code>后置通知的执行</code></strong></p>
<p>Object res = doOther();</p>
<ul>
<li><p>参数传递：传值，传引用</p>
</li>
<li><p>myAfterReturning(res);</p>
<p>System.out.println(“res=” + res);</p>
</li>
</ul>
<p>例：</p>
<blockquote>
<p>1.定义接口业务方法</p>
</blockquote>
<pre><code class="java">public interface SomeService{
String doOther(String name,int age);
}</code></pre>
<blockquote>
<p>2.实现接口方法</p>
</blockquote>
<pre><code class="java">public class SomeServiceImpl implements SomeService{
    public String doOther(String name,int age){
        System.out.println(&quot;执行业务方法 doOther()&quot;);
        return &quot;abcd&quot;;
    }
}</code></pre>
<blockquote>
<p>3.定义切面</p>
</blockquote>
<pre><code class="java">/**
* @AfterReturning:后置通知
*/
@AfterReturning(value=&quot;execution(* *..SomeServiceImpl.doOther(..))&quot;,returning=&quot;result&quot;)
public void myAfterReturning(JoinPoint jp,Object result){
    //Object result:是目标方法执行后的返回值，根据返回值做你的切面功能处理
    System.out.println(&quot;后置通知：在目标方法之后执行的，获取的返回值是：&quot; + result);
    System.out.println(&quot;后置通知：获取方法的签名：&quot; + jp.getSignature());
    //修改目标方法的执行结果
    if(&quot;abcd&quot;.equals(result)){
      String s = (String)result;
      result = s.toUpperCase();
    }
    System.out.println(&quot;后置通知：在目标方法之后执行的功能增强，例如执行事务处理（切面）&quot; + result);
}</code></pre>
<h5 id="四、-Around环绕通知"><a href="#四、-Around环绕通知" class="headerlink" title="四、@Around环绕通知"></a>四、@Around环绕通知</h5><p><strong>@Around环绕通知-增强方法有<code>ProceedingJoinPoint</code>参数</strong></p>
<p>在目标方法执行之前之后执行。被注解为环绕增强的方法要有返回值，<code>Object 类型</code>。并且方法可以包含一个<code>ProceedingJoinPoint</code>类型的参数。接口<code>ProceedingJoinPoint</code>其有一个<code>proceed()</code>方法，用于执行目标方法。若目标方法有返回值，则该方法的返回值就是目标方法的返回值。最后，环绕增强方法将其返回值返回。该增强方法实际是拦截了目标方法的执行。</p>
<p><strong><code>环绕通知方法的定义格式</code></strong></p>
<ul>
<li>1、public</li>
<li>2、必须有一个返回值，推荐使用Object</li>
<li>3、方法名称自定义</li>
<li>4、方法有参数，固定的参数<code>ProceedingJoinPoint</code></li>
</ul>
<p><strong><code>@Around</code></strong></p>
<ul>
<li>环绕通知<ul>
<li>属性：value 切入点表达式</li>
<li>位置：在方法的定义上面</li>
</ul>
</li>
<li>特点<ul>
<li>1.它是功能最强的通知</li>
<li>2.在目标方法的前和后都能增强功能</li>
<li>3.控制目标方法是否被调用执行</li>
<li>4.修改原来的目标方法的执行结果，影响最后的调用结果</li>
</ul>
</li>
</ul>
<blockquote>
<p>环绕通知，等同于jdk动态代理的<strong>InvocationHandler</strong>接口</p>
<p>参数：ProceedingJoinPoint就等同于Method</p>
<p>作用：执行目标方法的</p>
<p>返回值：就是目标方法的执行结果，可以被修改</p>
<p><strong>环绕通知</strong>：经常做事务，在目标方法之前开启事务，执行目标方法，在目标方法之后提交事务</p>
</blockquote>
<p>例:</p>
<blockquote>
<p>1.定义接口方法</p>
</blockquote>
<pre><code class="java">public inteface SomeService{
    String doFirst(String name,int age);
}</code></pre>
<blockquote>
<p>2.接口方法的实现</p>
</blockquote>
<pre><code class="java">@Component
public class SomeServiceImpl implements SomeService{
    @Override
    public String doFirst(String name,int age){
        System.out.println(&quot;执行了业务方法doFirst()&quot;);
        return &quot;doFirst&quot;;
    }
}</code></pre>
<blockquote>
<p>3.定义切面</p>
<ul>
<li><strong>ProceedingJoinPoint</strong>继承<strong>JoinPoint</strong>,可以直接使用<strong>JoinPoint</strong>的方法</li>
</ul>
</blockquote>
<pre><code class="java">@Component
public class MyAspect{
@Around(value=&quot;execution(* *..SomeServiceImpl.doFirst(..))&quot;)
    public Object myAround(ProceedingJoinPoint pjp) throws Throwable{
    String name = &quot;&quot;;
    //获取第一个参数（ProceedingJoinPoint继承JoinPoint，可以直接使用 JoinPoint的方法）
    Object[] args = pjp.getArgs();
    if(args != null &amp;&amp; args.length &gt; 1){
    Object arg = args[0];
    name = (String)arg;
    }
    //实现环绕通知
    Object result = null;
    //增强功能
    System.out.println(&quot;环绕通知：在目标方法之前，输出时间：&quot; + new Date());
    //执行目标方法的调用
    if(&quot;zhangsan&quot;.equals(name)){
    //符合条件，调用目标方法
    result = pjp.proceed();  //等同于 method.invoke(target,args);    Object result = doFirst();
    }
    //增强功能
    System.out.println(&quot;环绕通知：在目标之后，提交事务&quot;);
    //修改目标方法的执行结果，影响方法最后的调用结果
    if(result != null){
    result = &quot;Hello AspectJ AOP&quot;;
    }
    //返回目标方法的执行结果
    return result;
    }
}  </code></pre>
<blockquote>
<p>4.定义测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test01(){
    String config = &quot;applicationContext.xml&quot;;
    ApplicationContext ac = new ClassPathXmlApplicationContext(config);
    SomeService proxy = (SomeService)ac.getBean(&quot;someServiceImpl&quot;);
    String str = proxy.doFirst(&quot;zhangsan&quot;,20); //相当于执行的是myAround();
}</code></pre>
<h5 id="五、-AfterThrowing异常通知"><a href="#五、-AfterThrowing异常通知" class="headerlink" title="五、@AfterThrowing异常通知"></a>五、@AfterThrowing异常通知</h5><p><strong>@AfterThrowing异常通知-注解中有<code>throwing</code>属性</strong></p>
<p>在目标方法抛出异常后执行。该注解的 <code>throwing</code>属性用于指定所发生的异常类对象。当然，被注解为异常通知的方法可以包含一个参数<code>Throwable</code>,参数名称为<code>throwing</code>指定的名称，表示发生的异常对象。</p>
<p><strong><code>异常通知方法的定义格式</code></strong></p>
<ul>
<li>1、public</li>
<li>2、没有返回值</li>
<li>3、方法名称自定义</li>
<li>4、方法有一个参数<code>Exception</code>，如果还有是<code>JoinPoint</code></li>
</ul>
<p><strong><code>@AfterThrowing</code></strong></p>
<ul>
<li><p>异常通知</p>
<ul>
<li><p>属性：</p>
<ol>
<li><p>value    切入点表达式</p>
</li>
<li><p><code>throwing</code> 自定义的变量，表示目标方法抛出的异常对象</p>
<p><strong>变量名必须和方法的参数名一样</strong></p>
</li>
</ol>
</li>
<li><p>特点</p>
<ul>
<li>在目标方法抛出异常时执行</li>
<li>可以做异常的监控程序，监控目标方法执行时是不是有异常,如果有异常，可以发送邮件，短信进行通知</li>
</ul>
</li>
<li><p>执行就是：</p>
<pre><code class="java">   try{
       SomeServiceImpl.doSecond(..);
   }catch(Exception e){
       myAfterThrowing(e);
   }</code></pre>
</li>
</ul>
</li>
</ul>
<p>例:</p>
<blockquote>
<p>1.定义业务接口</p>
</blockquote>
<pre><code class="java">public interface SomeService{
  void doSecond();
}</code></pre>
<blockquote>
<p>2.定义接口实现类</p>
</blockquote>
<pre><code class="java">@Component
public class SomeServiceImpl implements SomeService{
  @Override
  public void doSecond(){
    System.out.println(&quot;执行业务方法doSecond()&quot; + 10/0);
  }
}</code></pre>
<blockquote>
<p>3.定义切面</p>
</blockquote>
<pre><code class="java">@Component
/**
 * @AfterThrowing:异常通知
 */
@AfterThrowing(value=&quot;execution(* *..SomeServiceImpl.doSecond(..))&quot;,throwing= &quot;ex&quot;)
public void myAfterThrowing(Exception ex){
  System.out.println(&quot;异常通知：方法发生异常时，执行&quot; + ex.getMessage());
  //发送邮件，短信，通知开发人员
}</code></pre>
<blockquote>
<p>4.定义测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test01(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  SomeService proxy = (SomeService)ac.getBean(&quot;someServiceImpl&quot;);
  //通过代理对象执行方法，实现目标方法执行时，增强了功能
  //当有异常发生时，执行切面的功能报告异常
  proxy.doSecond();
}</code></pre>
<h5 id="六、-After-最终通知"><a href="#六、-After-最终通知" class="headerlink" title="六、@After 最终通知"></a>六、@After 最终通知</h5><p><strong>无论目标方法是否抛出异常，该增强均会被执行</strong> </p>
<p><strong><code>最终方法的定义格式</code></strong></p>
<ul>
<li>1、public</li>
<li>2、没有一个返回值</li>
<li>3、方法名称自定义</li>
<li>4、方法没有参数，如果有事JoinPoint</li>
</ul>
<p><strong><code>@After</code></strong></p>
<ul>
<li><p>最终通知</p>
<ul>
<li>属性：value 切入点表达式</li>
<li>位置：在方法的上面</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>1、总是会被执行</p>
</li>
<li><p>2、在目标方法之后执行的</p>
</li>
<li><p>3、相当于</p>
<pre><code class="java">try{

}catch(Exception e){

}finally{
    myAfter();
}</code></pre>
</li>
</ul>
</li>
</ul>
<p>例：</p>
<blockquote>
<p>1.定义目标接口</p>
</blockquote>
<pre><code class="java">public interface SomeService{
  void doThird();
}</code></pre>
<blockquote>
<p>2.定义接口实现类</p>
</blockquote>
<pre><code class="java">public class SomeServiceImpl implements SomeService{
  public void doThird(){
    System.out.println(&quot;执行业务方法doThird()&quot; + 10/0);
  }
}</code></pre>
<blockquote>
<p>3.定义切面</p>
</blockquote>
<pre><code class="java">/*
 * @After:最终通知
 */
@After(value=&quot;execution(* *..SomeServiceImpl.doThird(..))&quot;)
public void myAfter(){
  System.out.println(&quot;执行最终通知，总是会被执行的代码&quot;)；
  //一般做资源清除工作的
}</code></pre>
<blockquote>
<p>4.定义测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test01(){
  String config = &quot;applicationContext.xml&quot;;
  ApplicationContext ac = new ClassPathXmlApplicationContext(config);
  SomeService proxy = (SomeService)ac.getBean(&quot;someService&quot;);
  proxy.doThird();
}</code></pre>
<h5 id="七、Pointcut-定义切入点"><a href="#七、Pointcut-定义切入点" class="headerlink" title="七、Pointcut 定义切入点"></a>七、Pointcut 定义切入点</h5><ul>
<li>当较多的通知方法使用相同的 execution 切入点表达式时，编写、维护均较为麻烦。AspectJ 提供了<code>@Pointcut</code> 注解，用于定义 execution 切入点表达式。</li>
<li>其用法是，将<code>@Pointcut</code>注解在一个方法上，以后所有的 execution 的 value 属性值均可使用该方法名作为切入点。代表的就是<code>@Pointcut</code>定义的切入点。这个<code>@Pointcut</code>注解的方法一般使用<code>private</code>的标识方法，即没有实际作用的方法。</li>
</ul>
<p><strong><code>@Pointcut</code></strong></p>
<p>定义和管理切入点，如果你的项目中有多个切入点表达式是重复的，可以复用的。可以使用@Pointcut</p>
<ul>
<li>属性：value 切入点表达式</li>
<li>位置：在自定义的方法上面</li>
<li>特点<ul>
<li>当使用@Pointcut定义在一个方法上面，此时这个方法的名称就是切入点表达式的别名。其它的通知中，value属性就可以使用这个方法名称，代替切入点表达式了。</li>
</ul>
</li>
</ul>
<p>例:</p>
<pre><code class="java">@Before(value=&quot;mypt()&quot;)
public void MyBefore(){
  System.out.println(&quot;前置通知，在目标方法之前执行的&quot;);
}

@Pointcut(value=&quot;execution(* *..SomeServiceImpl.doThird(..))&quot;)
private void mypt(){
  //无需代码
}</code></pre>
<h4 id="5、CGLIB-动态代理"><a href="#5、CGLIB-动态代理" class="headerlink" title="5、CGLIB 动态代理"></a>5、CGLIB 动态代理</h4><p><strong>目标类没有接口，使用cglib动态代理，spring框架会自动应用cglib</strong></p>
<blockquote>
<p>1.定义目标类</p>
</blockquote>
<pre><code class="java">//目标类
public class SomeServiceImpl{
    public void doThird(){
         System.out.println(&quot;执行业务方法 doThird()&quot;);
    }
}</code></pre>
<blockquote>
<p>2.定义切面类</p>
</blockquote>
<pre><code class="java">@Aspect
public class MyAspect{
    @After(value=&quot;execution(* *..SomeServiceImpl.doThird(..))&quot;)
    public void myAfter(){
         System.out.println(&quot;执行最终通知，总是会被执行的代码&quot;);
    }
}</code></pre>
<blockquote>
<p>3.定义测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test01(){
    String config = &quot;applicationContext.xml&quot;;
    ApplicationContext ac = new ClassPathXmlApplicationContext(config);
    //从容器中获取目标对象
    SomeServiceImpl proxy = (SomeServiceImpl) ac.getBean(&quot;someService&quot;);
    /*
   * 目标类没有接口，使用 cglib 动态代理，spring 框架会自动应用 cglib
   * proxy.getClass().getName() = 
   * com.bjpowernode.ba07.SomeServiceImpl$$EnhancerBySpringCGLIB$$ef83cd08
   */
  System.out.println(&quot;proxy.getClass().getName() = &quot; + proxy.getClass().getName());
  // 通过代理的对象执行方法，实现目标方法执行时，增强了功能
  proxy.doThird();
}</code></pre>
<h5 id="如果你期望目标类有接口，并且使用cglib代理"><a href="#如果你期望目标类有接口，并且使用cglib代理" class="headerlink" title="如果你期望目标类有接口，并且使用cglib代理"></a>如果你期望目标类有接口，并且使用cglib代理</h5><ul>
<li>在 applicationContext.xml 文件中添加标签<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></li>
<li><code>proxy-target-class=&quot;true&quot;</code> : 告诉框架，要使用 cglib 动态代理</li>
</ul>
<pre><code class="xml">&lt;!--把对象交给 spring 容器，由 spring 容器统一创建，管理对象--&gt;
    &lt;!--声明目标对象--&gt;
    &lt;bean id=&quot;someService&quot; class=&quot;com.bjpowernode.ba05.SomeServiceImpl&quot;/&gt;
    &lt;bean id=&quot;myAspect&quot; class=&quot;com.bjpowernode.ba05.MyAspect&quot; /&gt;

    &lt;!--声明自动代理生成器：使用 aspectj 框架内部的功能，创建目标对象的代理对象。
        创建代理对象是在内存中实现的，修改目标对象在内存中的结构。创建为代理对象
        所以目标对象就是被修改后的代理对象

        aspectj-autoproxy：会把 spring 容器中的所有的目标对象，一次性都生成代理对象
    --&gt;

    &lt;!--&lt;aop:aspectj-autoproxy /&gt;--&gt;

    &lt;!--
        如果你期望目标类有接口，使用 cglib 代理
        proxy-target-class=&quot;true&quot; : 告诉框架，要使用 cglib 动态代理
    --&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></pre>
<hr>
<h2 id="八、Spring-集成-MyBatis"><a href="#八、Spring-集成-MyBatis" class="headerlink" title="八、Spring 集成 MyBatis"></a>八、Spring 集成 MyBatis</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ul>
<li><p>把 mybatis 框架和spring集成在一起，像一个框架一样使用</p>
</li>
<li><p>用的技术是：IOC</p>
</li>
<li><p>为什么IOC 能把mybatis和 spring集成在一起，像一个框架，是因为IOC能创建对象，可以把mybatis框架中的对象交给spring统一创建，开发人员从 spring中获取对象。开发人员就不用同时面对两个或多个框架了，就面对一个 spring</p>
</li>
<li><p>mybatis使用步骤，对象</p>
<ul>
<li><p>1、定义 dao 接口，StudentDao</p>
</li>
<li><p>2、定义 mapper文件 StudentDao.xml</p>
</li>
<li><p>3、定义 mybatis 的主配置文件 mybatis.xml</p>
</li>
<li><p>4、创建 dao 的代理对象，StudentDao dao = SqlSession.getMapper(StudenDao.class);</p>
<ul>
<li>List<student> students = dao.selectStudents();</student></li>
</ul>
</li>
</ul>
</li>
<li><p>要使用 dao 对象，需要使用 getMapper()方法</p>
<ul>
<li><p>怎么能使用getMapper()方法，需要哪些条件</p>
<ol>
<li><p>获取SqlSession对象，需要使用SqlSessionFactory的openSession()方法</p>
</li>
<li><p>创建SqlSessionFactory对象。通过读取mybatis的主配置文件，能创建SqlSessionFactory对象</p>
</li>
</ol>
</li>
<li><p>需要SqlSessionFactory对象，使用Factory能获取SqlSession，有了 SqlSession就能有 dao，目的就是获取dao 对象</p>
</li>
<li><p>Factory 创建需要读取主配置文件</p>
</li>
</ul>
</li>
</ul>
<p><strong><code>主配置文件</code></strong></p>
<p>1.数据库信息</p>
<pre><code class="xml">&lt;environment id=&quot;mydev&quot;&gt;
    &lt;transactionManager type=&quot;JDBC&quot; /&gt;
    &lt;dataSource type=&quot;POOLED&quot;&gt;
        &lt;!--数据库的驱动类名--&gt;
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
        &lt;!--连接数据库的 url 字符串--&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/springdb&quot; /&gt;
        &lt;!--访问数据库的用户名--&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;!--密码--&gt;
        &lt;property name=&quot;password&quot; value=&quot;shixiang&quot; /&gt;
    &lt;/dataSource&gt;
&lt;/environment&gt;</code></pre>
<p>2.mapper 文件的位置</p>
<pre><code class="xml">&lt;mappers&gt;
    &lt;mapper resource=&quot;com/bjpowernode/dao/Student.xml&quot; /&gt;
&lt;/mappers&gt;</code></pre>
<ul>
<li>通过以上的说明，我们需要让 spring 创建以下对象<ul>
<li>1.独立的连接池类的对象，使用阿里的 druid 连接池</li>
<li>2.SqlSessionFactory 对象</li>
<li>3.创建出 dao 对象</li>
</ul>
</li>
<li>需要学习就是上面三个对象的创建语法，使用 xml 的 bean 标签</li>
</ul>
<h3 id="二、集成步骤"><a href="#二、集成步骤" class="headerlink" title="二、集成步骤"></a>二、集成步骤</h3><ul>
<li>1、新建 maven 项目</li>
<li>2、加入 maven依赖<ul>
<li>spring 依赖</li>
<li>mybatis 依赖</li>
<li>mysql 驱动</li>
<li>spring 的事务的依赖</li>
<li>mybatis 和 spring 集成的依赖：mybatis 官方提供的，用来在 spring 项目中创建 mybatis 的SqlSessionFactory，dao 对象</li>
<li>druid 数据库连接池依赖</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
 &lt;!--单元测试--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;junit&lt;/groupId&gt;
   &lt;artifactId&gt;junit&lt;/artifactId&gt;
   &lt;version&gt;4.11&lt;/version&gt;
   &lt;scope&gt;test&lt;/scope&gt;
 &lt;/dependency&gt;
 &lt;!--spring核心ioc--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
   &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!--做 spring事务用到的--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
   &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
   &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!--mybatis依赖--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
   &lt;version&gt;3.5.1&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!--mybatis和 spring集成的依赖--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
   &lt;version&gt;1.3.1&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!--mysql驱动--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
   &lt;version&gt;5.1.9&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;!--阿里公司的数据库连接池--&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
   &lt;artifactId&gt;druid&lt;/artifactId&gt;
   &lt;version&gt;1.1.12&lt;/version&gt;
 &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<ul>
<li><p>3、创建实体类</p>
<ul>
<li>com.bjpowernode.domain 包</li>
<li>数据库表已创建好，学生有id、name、email、age 字段</li>
</ul>
<pre><code class="java">public class Student{
  //属性名和列名一样
  private Integer id;
  private String name;
  private String email;
  private Integer age;
  //有参和无参构造
  //setter and getter
  //toString
}</code></pre>
</li>
<li><p>4、创建 dao 接口和 mapper 文件</p>
<pre><code class="java">public interface StudentDao{
    int insertStudent(Student student);
    List&lt;Student&gt; selectStudents();
}</code></pre>
<pre><code class="xml">&lt;mapper namespace=&quot;com.bjpowernode.dao.StudentDao&quot;&gt;
 &lt;insert id=&quot;insertStudent&quot; &gt;
     insert into student values (#{id},#{name},#{email},#{age})
 &lt;/insert&gt;
 &lt;select id=&quot;selectStudents&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt;
     select id,name,email,age from student order by id desc
 &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
</li>
<li><p>5、创建 mybatis 主配置文件</p>
<pre><code class="xml">&lt;configuration&gt;
 &lt;!-- settings: 控制 mybatis 全局行为 --&gt;
 &lt;settings&gt;
     &lt;!-- 设置 mybatis 输出日志 --&gt;
     &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
 &lt;/settings&gt;

 &lt;!--设置别名--&gt;
 &lt;typeAliases&gt;
     &lt;!--name:实体类所在的包名--&gt;
     &lt;package name=&quot;com.bjpowernode.domain&quot;/&gt;
 &lt;/typeAliases&gt;

 &lt;!--sql mapper（sql 映射文件）的位置--&gt;
 &lt;mappers&gt;
     &lt;!--
         name ：是包名，这个包中的所有mapper.xml 文件一次都能加载
     --&gt;
     &lt;package name=&quot;com.bjpowernode.dao&quot;/&gt;
 &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
</li>
<li><p>6、创建 Service 接口和实现类，属性是 dao</p>
<ul>
<li>com.bjpowernode.service 包</li>
</ul>
<pre><code class="java">public interface StudentService{
int addStudent(Student student);
List&lt;Student&gt; queryStudent();
}</code></pre>
<ul>
<li>实现接口</li>
</ul>
<pre><code class="java">public class StudentServiceImpl implements StudentService{
  //引用类型
  private StudentDao studentDao;

  //使用 set 注入，赋值
  public void setStudentDao(StudentDao studentDao){
    this.studentDao = studentDao;
  }

  @Override
  public int addStudent(Student student){
    int nums = studentDao.insertStudent(student);
    return nums;
  }
  @Override
  public List&lt;Student&gt; queryStudent(){
    List&lt;Student&gt; students = studentDao.selectStudents();
    return students;
  }
}</code></pre>
</li>
<li><p>7、创建 spring 的配置文件：声明 mybatis 的对象交给spring 创建</p>
<ul>
<li>1、数据源</li>
<li>2、SqlSessionFactory</li>
<li>3、Dao 对象</li>
<li>4、声明自定义的 service</li>
</ul>
<blockquote>
<ul>
<li>把数据库的配置信息，写在一个独立的文件，便于修改数据库的配置内容</li>
<li>spring知道jdbc.properties文件的位置（放在 resources 目录 下）</li>
</ul>
</blockquote>
<pre><code class="properties">jdbc.url=jdbc:mysql://localhost:3306/springdb?useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=tenincense
jdbc.maxActive=20</code></pre>
<ul>
<li>配置 applicationcontext.xml 文件</li>
</ul>
<pre><code class="xml">&lt;!--
把数据库的配置信息，写在一个独立的文件，便于修改数据库的配置内容
spring 知道 jdbc.properties 文件的位置
--&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;

&lt;!--声明数据源DataSource,作用是连接数据库的--&gt;
&lt;!--class打 DruidDataSource 就出来了--&gt;
&lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; 
   init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
&lt;!--set 注入给 DruidDataSource提供连接数据库信息--&gt;
&lt;!--使用属性配置文件中的数据，语法 ${key}--&gt;
&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;property name=&quot;maxActive&quot; value=&quot;${jdbc.maxActive}&quot; /&gt;
&lt;/bean&gt;

&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean 类，这个类内部创建SqlSessionFactory的
        相当于SqlSessionFactory factory = new ...
--&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!--set 注入，把数据库连接池赋给了 dataSource 属性--&gt;
&lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
&lt;!--mybatis 主配置文件的位置
            configLocation 属性是 Resource 类型，读取配置文件
            它的赋值比较特殊，使用 value，指定文件的路径，使用 classpath: 表示文件的位置
    --&gt;
&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt;
&lt;/bean&gt;

&lt;!--创建 dao 对象，使用 SqlSession 的 getMapper(StudentDao.class)
    MapperScannerConfigurer:在内部调用 getMapper() 生成每个 dao 接口的代理对象
--&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;!--指定 SqlSessionFactory 对象的 id--&gt;
&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;
&lt;!--指定包名，包名是 dao 接口所在的包名
            MapperScannerConfigurer：Mapper 扫描配置器 会扫描这个包中的所有接口，把每个接口都执行
            一次 getMapper() 方法，得到每个接口的 dao 对象
            该 bean 无需 id 属性，创建好的 dao 对象默认接口首字母小写
            创建好的 dao 对象放入到 spring 的容器中。dao 对象默认名称是 接口首字母小写
    --&gt;
&lt;!--多个包可以使用 , 分隔--&gt;
&lt;property name=&quot;basePackage&quot; value=&quot;com.bjpowernode.dao&quot; /&gt;
&lt;/bean&gt;

&lt;!--声明 service--&gt;
&lt;bean id=&quot;studentService&quot; class=&quot;com.bjpowernode.service.impl.StudentServiceImpl&quot;&gt;
    &lt;property name=&quot;StudentDao&quot; ref=&quot;studentDao&quot; /&gt;  &lt;!--上面创建 dao 对象的首字母小写--&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>XML 文件中 &amp;要用&amp;amp;代替</p>
</blockquote>
</li>
<li><p>8、创建测试类，获取Service对象，通过service调用dao完成数据库的访问</p>
</li>
</ul>
<pre><code class="java">@Test
 public void test01(){
     String config = &quot;applicationContext.xml&quot;;
     ApplicationContext ac = new ClassPathXmlApplicationContext(config);
     String[] names =  ac.getBeanDefinitionNames();
     for (String name : names){
         System.out.println(&quot;  容器中对象的名称 = &quot; + name + &quot;|&quot; +         
                            ac.getBean(name).getClass().getName());
     }
 }

 @Test
 public void testDaoInsert(){
     String config = &quot;applicationContext.xml&quot;;
     ApplicationContext ac = new ClassPathXmlApplicationContext(config);
     // 获取 spring 容器中的 dao 对象
     StudentDao dao = (StudentDao) ac.getBean(&quot;studentDao&quot;);
     Student student = new Student(1007,&quot;张三&quot;,&quot;lili@qq.com&quot;,20);
     int nums = dao.insertStudent(student);
     System.out.println(&quot;nums = &quot; + nums);
 }

 @Test
 public void testServiceInsert(){
     String config = &quot;applicationContext.xml&quot;;
     ApplicationContext ac = new ClassPathXmlApplicationContext(config);
     // 获取 spring 容器中的 Service 对象
     SomeService service = (SomeService) ac.getBean(&quot;studentService&quot;);
     Student student = new Student(1008,&quot;张三&quot;,&quot;lililili@qq.com&quot;,21);
     int nums = service.addStudent(student);
     //spring 和 mybatis 整合在一起使用，事务是自动提交的。无需执行SqlSession.commit();
     System.out.println(&quot;nums = &quot; + nums);
 }

 @Test
 public void testServiceSelect(){
     String config = &quot;applicationContext.xml&quot;;
     ApplicationContext ac = new ClassPathXmlApplicationContext(config);
     // 获取 spring 容器中的 Service 对象
     SomeService service = (SomeService) ac.getBean(&quot;studentService&quot;);
     List&lt;Student&gt; list = service.queryStudent();
     for (Student student : list){
         System.out.println(&quot;student = &quot; + student);
     }

 }</code></pre>
<hr>
<h2 id="九、Spring事务"><a href="#九、Spring事务" class="headerlink" title="九、Spring事务"></a>九、Spring事务</h2><h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="一、什么是事务"><a href="#一、什么是事务" class="headerlink" title="一、什么是事务"></a>一、什么是事务</h4><ul>
<li>讲 mysql的时候，提出来事务</li>
<li>事务是指一组 sql 语句的集合，集合中有多条 sql 语句可能是 insert、update，select，delete，我们希望这些多个 sql 语句都成功，或者都失败，这些 sql 语句执行是一致的，作为一个整体执行。</li>
</ul>
<h4 id="二、什么时候想到使用事务"><a href="#二、什么时候想到使用事务" class="headerlink" title="二、什么时候想到使用事务"></a>二、什么时候想到使用事务</h4><ul>
<li>当我们的操作，涉及到多个表，或者是多个sql 语句的insert、update、delete。需要保证这些语句都是成功才能完成我们的功能，或者都失败，保证操作是符合要求的。</li>
<li>在 java 代码中写程序，控制事务，此时事务应该放到哪里呢？<ul>
<li>service 类的业务方法上，因为业务方法会调用多个 dao 方法，执行多个 sql 语句（通过 service 调用 dao）</li>
</ul>
</li>
</ul>
<h4 id="三、通常使用-JDBC-访问数据库，还是-mybatis-访问数据库怎么处理事务"><a href="#三、通常使用-JDBC-访问数据库，还是-mybatis-访问数据库怎么处理事务" class="headerlink" title="三、通常使用 JDBC 访问数据库，还是 mybatis 访问数据库怎么处理事务"></a>三、通常使用 JDBC 访问数据库，还是 mybatis 访问数据库怎么处理事务</h4><ul>
<li>jdbc 访问数据库处理事务（try catch 中）</li>
<li>mybatis 访问数据库，处理事务，sqlSession.commit(); sqlSession.rollback();</li>
<li>Hibernate 访问数据库，处理事务，Session.commit();Session.rollback();</li>
</ul>
<h4 id="四、以上问题中事务的处理方式，有什么不足"><a href="#四、以上问题中事务的处理方式，有什么不足" class="headerlink" title="四、以上问题中事务的处理方式，有什么不足"></a>四、以上问题中事务的处理方式，有什么不足</h4><ul>
<li>不同的数据访问技术，处理事务的对象，方法不同，需要了解不同数据库访问技术使用事务的原理</li>
<li>掌握多种数据库中事务的处理逻辑，什么时候提交事务，什么时候回滚事务</li>
<li>处理事务的多种方法</li>
</ul>
<p><strong>总结：就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法。</strong></p>
<h4 id="五、怎么解决不足"><a href="#五、怎么解决不足" class="headerlink" title="五、怎么解决不足"></a>五、怎么解决不足</h4><ul>
<li>spring 提供一种处理事务的统一模型。能够使用统一步骤、方式完成多种不同数据库访问技术的事务处理。</li>
<li>使用spring的事务处理机制，可以完成mybatis访问数据库的事务处理</li>
<li>使用 spring的事务处理机制，可以完成hibernate访问数据库的事务处理</li>
</ul>
<h4 id="六、处理事务，需要怎么做，做什么"><a href="#六、处理事务，需要怎么做，做什么" class="headerlink" title="六、处理事务，需要怎么做，做什么"></a>六、处理事务，需要怎么做，做什么</h4><p><strong>1、spring处理事务的模型，使用的步骤都是固定的，把事务使用的信息提供给spring就可以了</strong></p>
<ul>
<li>事务内部提交、回滚事务，使用的事务管理对象，代替你完成commit，rollback</li>
<li>接口：PlatformTransactionManager，定义了事务重要方法 commit，rollback</li>
<li>实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了<ul>
<li>mybatis 访问数据库—–spring创建好的是 DataSourceTransactionManager</li>
<li>hibernate 访问数据库—-spring 创建好的是HibernateTransactionManager</li>
</ul>
</li>
</ul>
<p><strong><code>怎么使用</code></strong></p>
<p>你需要告诉 spring 你用的是那种数据库的访问技术，怎么告诉 spring 呢</p>
<ul>
<li><p>声明数据库访问技术对应的实现类，在 spring 的配置文件中使用 <bean>声明就可以了</bean></p>
</li>
<li><p>例如，你要使用 mybatis 访问数据库，你应该在 xml 配置文件中</p>
<pre><code class="xml">&lt;bean id=&quot;xxx&quot; class=&quot;...DataSourceTransactionManager&quot; /&gt;</code></pre>
</li>
</ul>
<p><strong>2、你的业务方法需要什么样的事务，说明需要事务的类型</strong></p>
<ul>
<li>说明方法需要的事务：</li>
</ul>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><ul>
<li>1、事务的隔离级别：有 4 个值<ul>
<li><strong>DEFAULT</strong>:采用 DB 默认的事务隔离级别。MySql的默认值为 REPEATABLE_READ;Oracle 默认为 READ_COMMITTED</li>
<li><strong>READ_UNCOMMITTED</strong>:读未提交。未提交任何并发问题。 </li>
<li><strong>READ_COMMITTD</strong>:读已提交。解决脏读、存在不可重复读与幻读。 </li>
<li><strong>REPEATABLE_READ</strong>:可重复读。解决脏读、不可重复读，存在幻读 </li>
<li><strong>SERIALIZABLE</strong>：串行化。不存在并发问题。  </li>
</ul>
</li>
</ul>
<h5 id="事务超时时间"><a href="#事务超时时间" class="headerlink" title="事务超时时间"></a>事务超时时间</h5><ul>
<li>2、事务的超时时间：表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚<ul>
<li>单位是秒，整数值，默认是 -1</li>
<li>常量 TIMEOUT_DEFAULT定义了事务底层默认的超时时限，sql 语句的执行时长。注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可</li>
</ul>
</li>
</ul>
<h5 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h5><ul>
<li><p>3、事务的传播行为：控制业务方法是不是有事务的，是什么样的事务的</p>
<ul>
<li><p>7 个传播行为，表示你的业务方法在调用时，事务在方法之间是如何使用的。</p>
<ul>
<li><p><code>PROPAGATION_REQUIRED</code>:指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的失去传播行为。</p>
</li>
<li><p><code>PROPAGATION_REQUIRED_NEW</code>:总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</p>
</li>
<li><p><code>PROPAGATION_SUPPORTS</code>:指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。（例如查询操作有事务和无事务都行）</p>
<ul>
<li><strong>以上三个需要掌握的</strong></li>
</ul>
</li>
<li><p>PROPAGATION_MANDATORY </p>
</li>
<li><p>PROPAGATION_NESTED</p>
</li>
<li><p>PROPAGATION_NEVER</p>
</li>
<li><p>PROPAGATION_NOT_SUPPORTED</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="提交和回滚事务时机"><a href="#提交和回滚事务时机" class="headerlink" title="提交和回滚事务时机"></a>提交和回滚事务时机</h5><ul>
<li>4、spring 提交事务，回滚事务的时机<ul>
<li>1）当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring 在方法执行后提交事务。事务管理器的 commit();</li>
<li>2）当你的业务方法抛出<em>运行时异常</em> 或 <em>ERROR</em> ，spring 执行回滚，调用事务管理器的 rollback();</li>
<li>3）当你的业务方法抛出<em>非运行时异常</em>，主要是<em>受查异常</em>时，提交事务<ul>
<li>受查异常：在你写代码时，必须处理的异常。例如 IOException，SQLException</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="总结-spring-的事务"><a href="#总结-spring-的事务" class="headerlink" title="总结 spring 的事务"></a>总结 spring 的事务</h5><ul>
<li>1、管理事务的是 事务管理器和他的实现类</li>
<li>2、spring 的事务是一个统一模型<ul>
<li>1、指定要使用的事务管理器实现类，使用<bean></bean></li>
<li>2、指定哪些类，哪些方法需要加入事务的功能</li>
<li>3、指定方法需要的隔离级别，传播行为，超时你需要告诉spring，你项目中类的信息，方法的名称，方法的传播行为。</li>
</ul>
</li>
</ul>
<h3 id="二、spring-框架中提供的事务处理方案"><a href="#二、spring-框架中提供的事务处理方案" class="headerlink" title="二、spring 框架中提供的事务处理方案"></a>二、spring 框架中提供的事务处理方案</h3><h4 id="一、注解方案"><a href="#一、注解方案" class="headerlink" title="一、注解方案"></a>一、注解方案</h4><p>比较适合小项目使用的</p>
<ul>
<li>spring 框架自己用 aop 实现给业务方法增加事务的功能，使用<code>@Transactional</code>注解增加事务。</li>
<li><code>@Transactional</code>注解是 spring 框架自己的注解，放在 public 方法的上面，表示当前方法具有事务。</li>
<li>可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等</li>
</ul>
<h5 id="使用-Transactional的步骤"><a href="#使用-Transactional的步骤" class="headerlink" title="使用@Transactional的步骤"></a>使用@Transactional的步骤</h5><ul>
<li><p>1、需要声明事务管理器对象</p>
<pre><code class="xml">&lt;bean id=&quot;xxx&quot; class=&quot;DataSourceTransactionManager&quot;&gt;</code></pre>
</li>
<li><p>2、开启事务注解驱动，告诉 spring 框架，我们使用注解的方式管理事务</p>
<ul>
<li><p>spring 使用 aop 机制，创建@Transactional所在的类代理对象，给方法加入事务的功能</p>
</li>
<li><p>spring 给业务方法加入事务：</p>
<ul>
<li>在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用 aop 的环绕通知</li>
</ul>
<pre><code class="java">@Around(&quot;你要增加的事务功能的业务方法名称&quot;)
Object myAround(){
    //开启事务，spring 给你开启
  try{
    buy(1001,10);
    spring 的事务管理器.commit();
  }catch(Exception e){
    spring 的事务管理.rollback();
  }
}</code></pre>
</li>
</ul>
</li>
<li><p>3、在你的方法上面加入@Transactional</p>
</li>
</ul>
<p>例：</p>
<blockquote>
<p>1、创建数据库表</p>
</blockquote>
<ul>
<li><p>sale 销售表</p>
<pre><code class="sql">create table sale(
    id int(11) primary key auto_increment,
  gid int(11) not null, #订单编号
  nums int(11) #订单数量
);</code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>gid</th>
<th>nums</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>1005</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>20</td>
</tr>
</tbody></table>
<ul>
<li><p>goods 商品表</p>
<pre><code class="sql">create table goods(
    id int(11) primary key, #商品名称
  name varchar(100), #商品名称
  amount int(11), #库存
  price float    #单价
);</code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>amount</th>
<th>price</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>笔记本电脑</td>
<td>100</td>
<td>5000</td>
</tr>
<tr>
<td>1002</td>
<td>手机</td>
<td>100</td>
<td>3000</td>
</tr>
</tbody></table>
<blockquote>
<p>2、新建 maven 项目</p>
</blockquote>
<blockquote>
<p>3、加入 maven 依赖 pom.xml</p>
</blockquote>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.11&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
  &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
  &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
  &lt;version&gt;5.1.9&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;druid&lt;/artifactId&gt;
  &lt;version&gt;1.1.12&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--插件--&gt;
&lt;build&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;includes&gt;
          &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;include&gt;**/*.properties&lt;/include&gt;
      &lt;/includes&gt;
      &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;includes&gt;
          &lt;include&gt;**/*.xml&lt;/include&gt;
      &lt;/includes&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;</code></pre>
<blockquote>
<p>4、创建实体类</p>
</blockquote>
<ul>
<li><p>1、实体类 Sale</p>
<pre><code class="java">public class Sale{
  private Integer id;
  private Integer gid;
  private Integer nums;
  //Setter and Getter
}</code></pre>
</li>
<li><p>2、实体类 Goods</p>
<pre><code class="java">public class Goods{
  private Integer id;
  private String name;
  private Integer amount;
  private float price;
  //Setter and Getter
}</code></pre>
</li>
</ul>
<blockquote>
<p>5、定义 dao 接口</p>
</blockquote>
<ul>
<li><p>1、SaleDao 接口</p>
<pre><code class="java">public interface SaleDao{
  //增加销售记录
  int insertSale(Sale sale);
}</code></pre>
</li>
<li><p>2、GoodsDao 接口</p>
<pre><code class="java">public interface Goods{
  //更新库存
  //goods 表示本次用户购买的商品信息，id，购买数量
  int updateGoods(Goods goods);

  //查询商品信息
  Goods selectGoods(Integer id);
}</code></pre>
</li>
</ul>
<blockquote>
<p>6、定义 dao 接口对应的 sql 映射文件</p>
</blockquote>
<ul>
<li><p>1、SaleDao.xml</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.bjpowernode.dao.SaleDao&quot;&gt;
    &lt;insert id=&quot;insertSale&quot; &gt;
        insert into sale(gid,nums) values (#{gid},#{nums})
    &lt;/insert&gt;
&lt;/mapper&gt;</code></pre>
</li>
<li><p>2、GoodsDao.xml</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.bjpowernode.dao.GoodsDao&quot;&gt;
    &lt;select id=&quot;selectGoods&quot; resultType=&quot;com.bjpowernode.domain.Goods&quot;&gt;
        select id,name,amount,price from goods where id = #{gid}
    &lt;/select&gt;

    &lt;update id=&quot;updateGoods&quot; &gt;
        update goods set amount = amount - #{amount} where id = #{id}
    &lt;/update&gt;
&lt;/mapper&gt;</code></pre>
</li>
</ul>
<blockquote>
<p>7、定义主配置文件mybatis.xml</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--name:实体类所在的包名--&gt;
        &lt;package name=&quot;com.bjpowernode.domain&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--sql mapper（sql 映射文件）的位置--&gt;
    &lt;mappers&gt;
        &lt;!--
            name ：是包名，这个包中的所有mapper.xml 文件一次都能加载
        --&gt;
        &lt;package name=&quot;com.bjpowernode.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<blockquote>
<p>8、定义异常类</p>
</blockquote>
<ul>
<li><p>1、定义 service 层可能会抛出的异常类 NotEnoughException</p>
<pre><code class="java">//自定义的运行时异常
public class NotEnoughException extends RuntimeException{
  public NotEnoughException (){
    super();
  }
  public NotEnoughException (String msg){
    super(msg);
  }
}</code></pre>
</li>
</ul>
<blockquote>
<p>9、定义 Service 接口</p>
</blockquote>
<ul>
<li><p>1、定义 Service 接口 BuyGoodsService</p>
<pre><code class="java">public interface BuyGoodsService{
  //购买商品的方法，goodId:购买商品的编号，amount：购买的数量
  void buy(Integer goodId,Integer amount);
}</code></pre>
</li>
<li><p>2、定义 service 层接口的实现类 BuyGoodsServiceImpl</p>
<pre><code class="java">public class BuyGoodsServiceImpl implements BuyGoodsService{
  private SaleDao saleDao;
  private GoodsDao goodsDao;
  public void setSaleDao(SaleDao saleDao){
    this.saleDao = saleDao;
  }
  public void setGoodsDao(GoodsDao goodsDao){
    this.goodsDao = goodsDao;
  }
  /*
   * rollbackFor : 表示发生指定的异常一定回滚
   *           处理逻辑 : 
                       1)spring 框架会首先检查方法抛出的异常是不是在 rollbckFor 的属性中
                           如果异常在 rollbackFor 的列表中，不管是什么类型的异常，一定回滚。
                       2）如果你抛出的异常不在 rollbackFor 列表中，spring 会判断异常是不是 
                           RuntimeException，如果是一定回滚。
   */
  /*
   * @Transaction(
   *         propagation = Propagation.REQUIRED,
   *        isolation = Isolation.DEFAULT,
   *        readOnly = false,
   *        rollbackFor = {
   *            NullPointerException.class,NotEnoughException.class
   *        }
   * )
   */

  // 使用的是事务控制的默认值，默认的传播行为 REQUIRED，默认的隔离级别 DEFAULT
  // 默认抛出运行时异常，回滚事务
  @Transactional
  @Override
  public void buy(Integer goodsId,Integer amount){
    System.out.println(&quot;buy 方法的开始&quot;);
    //记录销售信息，向 sale 表添加记录
    Sale sale = new Sale();
    sale.setGid(goodsId);
    sale.setNums(amount);
    saleDao.insertSale(sale);

    //更新库存
    Goods goods = goodsDao.selectGoods(goodsId);
    if(goods == null){
      //商品不存在
      throw new NullPointerException(&quot;编号是：&quot; + goodsId + &quot;商品不存在&quot;)；
    } else if(goods.getAmount() &lt; amount){
      //商品库存不足
      throw new NotEnoughException(&quot;编号是&quot; + goodsId + &quot;商品库存不足&quot;);
    }
    //修改库存
    Goods buyGoods = new Goods;
    buyGoods.setId(goodsId);
    buyGoods.setAmount(amount);
    goodsDao.updateGoods(buyGoods);
    System.out.println(&quot;buy方法的完成&quot;);
  }
}</code></pre>
</li>
</ul>
<blockquote>
<p>10、定义 spring 配置文件</p>
</blockquote>
<ul>
<li><p>1、数据库连接信息属性配置文件jdbc.properties</p>
<pre><code class="properties">jdbc.url=jdbc:mysql://localhost:3306/springdb?useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=shixiang
jdbc.maxActive=20</code></pre>
</li>
<li><p>2、spring 配置文件</p>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;
&lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destory-method=&quot;close&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;&lt;!--setUrl()--&gt;
  &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
  &lt;property name=&quot;maxActive&quot; value=&quot;${jdbc.maxActive}&quot; /&gt; &lt;!--指定最大连接数--&gt;
&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; &gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt;
&lt;/bean&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; &gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;
  &lt;property name=&quot;basePackage&quot; value=&quot;com.bjpowernode.dao&quot; /&gt; &lt;!--创建好的 dao 对象默认接口名首字母小写--&gt;
&lt;/bean&gt;
&lt;bean id=&quot;buyService&quot; class=&quot;com.bjpowernode.service.impl.BuyServiceImpl&quot; &gt;
    &lt;property name=&quot;SaleDao&quot; ref=&quot;saleDao&quot; /&gt;
  &lt;property name=&quot;GoodsDao&quot; ref=&quot;goodsDao&quot; /&gt;
&lt;/bean&gt;

&lt;!--声明 spring 的事务处理--&gt;
&lt;!--1.声明事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
  &lt;!--连接的数据库，指定数据源--&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
&lt;/bean&gt;
&lt;!--2.开启事务注解成功，告诉 spring 使用注解管理事务，创建代理对象
            transactionManager：事务管理对象的 id
--&gt;
&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</code></pre>
</li>
</ul>
<blockquote>
<p>11、测试类</p>
</blockquote>
<pre><code class="java">@Test
public void test01(){
   String config = &quot;applicationContext.xml&quot;;
   ApplicationContext ac = new ClassPathXmlApplicationContext(config);
   //从容器中获取 service
   BuyGoodsService service = (BuyGoodsService) ac.getBean(&quot;buyService&quot;);

   //service是代理： com.sun.proxy.$Proxy16 : jdk 动态代理
   System.out.println(&quot;service是代理： &quot; + service.getClass().getName());
   //调用方法
   service.buy(1001,200);
}</code></pre>
<h6 id="12、使用-spring-的事务注解管理事务（掌握）"><a href="#12、使用-spring-的事务注解管理事务（掌握）" class="headerlink" title="12、使用 spring 的事务注解管理事务（掌握）"></a>12、使用 spring 的事务注解管理事务（掌握）</h6><ul>
<li>通过@Transactional注解方式，可将事务织入到相应 public 方法，实现事务管理</li>
<li>@Transactional的所有可选属性如下所示：<ul>
<li><code>propagation</code>：用于设置事务传播属性。该属性类型为 Propagation枚举，默认值为 Propagation.REQUIRED</li>
<li><code>isolation</code>:用于设置事务的隔离级别。该属性类型为Isolation枚举，默认值为Isolation.DEFAULT</li>
<li><code>readOnly</code>:用于设置该方法对数据库的操作是否是只读的。该属性为boolean，默认值为false</li>
<li><code>timeout</code>：用于设置本操作与数据库连接的超时时限。单位为秒，类型为int，默认值为-1，即没有时限</li>
<li><code>rollbackFor</code>：指定需要回滚的异常类。类型为Class[],默认值为空数组。当然若只有一个异常类时，可以不使用数组</li>
<li><code>noRollbackFor</code>:指定不需要回滚的异常类。类型为Class[],默认值为空数组。当然若只有一个异常类时可以不使用数组</li>
<li><code>noRollbackForClassName</code>：指定不需要回滚的异常类类名。类型为String[],默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</li>
</ul>
</li>
<li>需要注意的是，@Transactional若用在方法上，只能用于<code>public</code>方法上。对于其它非public方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非public方法上的@Transactional注解。</li>
<li>若@Transactional注解在类上，则表示该类上所有的方法均将在执行时织入事务。</li>
</ul>
<h6 id="13、实现注解的事务步骤"><a href="#13、实现注解的事务步骤" class="headerlink" title="13、实现注解的事务步骤"></a>13、实现注解的事务步骤</h6><blockquote>
<p>1、创建以上的项目</p>
</blockquote>
<blockquote>
<p>2、声明事务管理器</p>
</blockquote>
<pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
  &lt;!--连接的数据库，指定数据源--&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>3、开启注解驱动</p>
</blockquote>
<pre><code class="xml">&lt;!--2.开启事务注解成功，告诉 spring 使用注解管理事务，创建代理对象
            transactionManager：事务管理对象的 id
--&gt;
&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</code></pre>
<blockquote>
<p>4、业务层 public 方法加入事务属性（业务层方法内调用多个 dao 层的 sql 方法，需要使用事务）</p>
</blockquote>
<pre><code class="java">/*
   * rollbackFor : 表示发生指定的异常一定回滚
   *           处理逻辑 : 
                       1)spring 框架会首先检查方法抛出的异常是不是在 rollbckFor 的属性中
                           如果异常在 rollbackFor 的列表中，不管是什么类型的异常，一定回滚。
                       2）如果你抛出的异常不在 rollbackFor 列表中，spring 会判断异常是不是 
                           RuntimeException，如果是一定回滚。
   */
  /*
   * @Transaction(
   *         propagation = Propagation.REQUIRED,
   *        isolation = Isolation.DEFAULT,
   *        readOnly = false,
   *        rollbackFor = {
   *            NullPointerException.class,NotEnoughException.class
   *        }
   * )
   */

  // 使用的是事务控制的默认值，默认的传播行为 REQUIRED，默认的隔离级别 DEFAULT
  // 默认抛出运行时异常，回滚事务
  @Transactional
  @Override
  public void buy(Integer goodsId,Integer amount){
    System.out.println(&quot;buy 方法的开始&quot;);
    //记录销售信息，向 sale 表添加记录
    Sale sale = new Sale();
    sale.setGid(goodsId);
    sale.setNums(amount);
    saleDao.insertSale(sale);

    //更新库存
    Goods goods = goodsDao.selectGoods(goodsId);
    if(goods == null){
      //商品不存在
      throw new NullPointerException(&quot;编号是：&quot; + goodsId + &quot;商品不存在&quot;)；
    } else if(goods.getAmount() &lt; amount){
      //商品库存不足
      throw new NotEnoughException(&quot;编号是&quot; + goodsId + &quot;商品库存不足&quot;);
    }
    //修改库存
    Goods buyGoods = new Goods;
    buyGoods.setId(goodsId);
    buyGoods.setAmount(amount);
    goodsDao.updateGoods(buyGoods);
    System.out.println(&quot;buy方法的完成&quot;);
  }</code></pre>
<h4 id="二、xml-配置"><a href="#二、xml-配置" class="headerlink" title="二、xml 配置"></a>二、xml 配置</h4><p><strong>比较适合大型项目</strong></p>
<ul>
<li>有很多类，方法，需要大量的配置事务，使用 aspectj框架功能，在 spring 配置文件中声明类，方法需要的事务。这种方式方法和事务配置完全分离。</li>
<li>都是在 xml 配置文件中实现</li>
</ul>
<h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><blockquote>
<p>1、要使用的是 aspectj框架，需要加入依赖</p>
</blockquote>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; 
    &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<blockquote>
<p>2、声明事务管理器对象</p>
</blockquote>
<pre><code class="xml">&lt;!--声明式事务处理：和源代码完全分离的--&gt;
&lt;!--1.声明事务管理器对象--&gt;
&lt;bean id=&quot;transactionManager&quot; 
      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; &gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
&lt;/bean&gt;</code></pre>
<blockquote>
<p>3、声明方法需要的事务类型（配置方法的事务【隔离级别（isolation）、传播行为（propagation）、超时timeout、指定异常类名（rollback-For）】）</p>
</blockquote>
<pre><code class="xml">&lt;!--2.声明业务方法它的事务属性（隔离级别，传播行为，超时时间）
        id:自定义名称，表示 tx:advice 和 &lt;/tx:advice&gt; 之间的配置内容的
        transaction-manager：事务管理器对象的 id
--&gt;
&lt;tx:advice id=&quot;myadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
  &lt;!--tx:attributes:配置事务属性--&gt;
    &lt;tx:attributes&gt;
    &lt;!--tx：method：给具体的方法配置事务属性，method 可以有多个，分别给不同的方法设置事务属性
        name：方法名称 1）完整的方法名称，不带有包和类
                      2）方法可以使用通配符，* 表示任意字符
        propagation：传播行为，枚举值
        isolation：隔离级别
        rollback-For：你指定的异常类名，全限定类名。发生异常一定回滚
    --&gt;
      &lt;tx:method name=&quot;buy&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; 
    rollback-for=&quot;java.lang.NullPointerException,com.bjpowernode.excep.NotEnoughException&quot;/&gt;
    &lt;!--使用通配符，指定很多的方法--&gt;
    &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRES_NEW&quot; /&gt;
    &lt;!--指定修改方法--&gt;
    &lt;tx:method name=&quot;modify*&quot; /&gt;
    &lt;!--删除方法--&gt;
    &lt;tx:method name=&quot;remove*&quot; /&gt;
    &lt;!--查询方法，query，search，find--&gt;
    &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
<blockquote>
<p>4、配置 aop ：指定哪些类要创建代理</p>
</blockquote>
<pre><code class="xml">&lt;!--配置 aop --&gt;
&lt;aop:config&gt;
    &lt;!--配置切入点表达式：指定哪些包中类，要使用事务
          id:切入点表达式的名称，唯一值
        expression：切入点表达式，指定哪些类要使用事务，aspectj 会创建代理对象

        com.bjpowernode.service
        com.crm.service
        com.service
  --&gt;
  &lt;aop:pointcut id=&quot;servicePt&quot; expression=&quot;execution(* *..service..*.*(..))&quot; /&gt;

  &lt;!--配置增强器：关联 advice 和 pointcut--&gt;
  &lt;aop:advisor advice-ref=&quot;myadvice&quot; pointcut-ref=&quot;servicePt&quot; /&gt;
&lt;/aop:config&gt;</code></pre>
<hr>
<h2 id="十、WEB-项目中使用容器对象"><a href="#十、WEB-项目中使用容器对象" class="headerlink" title="十、WEB 项目中使用容器对象"></a>十、WEB 项目中使用容器对象</h2><ul>
<li><p>1、做的是javase项目中有 main 方法的，执行代码是执行main 方法的，在main里面创建的容器对象</p>
<pre><code class="java">ApplicationContext ac = new ClaasPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></pre>
</li>
<li><p>2、web 项目是在tomcat服务器上运行的。tomcat 一启动，项目就一直运行的。</p>
</li>
<li><p>需求：</p>
<ul>
<li>在web项目中容器对象只创建一次，把容器对象放入到全局作用域 ServletContext 中。</li>
</ul>
</li>
</ul>
<h3 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h3><p><strong>使用监听器 当全局作用域对象被创建时，创建容器 存入到 ServletContext中</strong></p>
<h4 id="监听器作用"><a href="#监听器作用" class="headerlink" title="监听器作用"></a>监听器作用</h4><ul>
<li><p>1、创建容器对象，执行ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
</li>
<li><p>2、把容器对象放到ServletContext，ServletContext.setAttribute(key,ac);</p>
<ul>
<li><p>监听器可以自己创建，也可以使用框架中提供好的 ContextLoaderListener</p>
</li>
<li><p>监听器源码：</p>
<pre><code class="java">private WebApplicationContext context;
public interface WebApplicationContext extends ApplicationContext</code></pre>
<ul>
<li>ApplicationContext : javase 项目中使用的容器对象</li>
<li>WebApplicationContext：web 项目中使用的容器对象</li>
</ul>
</li>
<li><p>把创建好的容器对象，放入到全局作用域</p>
</li>
<li><p>key:WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</p>
<ul>
<li>value:this.context</li>
</ul>
</li>
<li><p>ServletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,this.context);</p>
</li>
</ul>
</li>
</ul>
<h3 id="在-web项目中使用-spring，完成学生注册功能"><a href="#在-web项目中使用-spring，完成学生注册功能" class="headerlink" title="在 web项目中使用 spring，完成学生注册功能"></a>在 web项目中使用 spring，完成学生注册功能</h3><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1、创建maven，web 项目</p>
<p>2、加入依赖</p>
<ul>
<li>servlet 依赖</li>
<li>jsp 依赖</li>
<li>为了使用监听器对象，加入 spring-web 依赖</li>
<li>spring 核心 ioc依赖 spring-context</li>
<li>spring 事务用的依赖 spring-tx、spring-jdbc</li>
<li>mybatis 依赖</li>
<li>mybatis 和 spring 集成的依赖</li>
<li>mysql 驱动</li>
<li>阿里公司的数据库连接池 druid</li>
</ul>
<p>3、创建实体类</p>
<pre><code class="java">public class Student{
  //属性名和列名一样
  private Integer id;
  private String name;
  private String email;
  private Integer age;
  //无参 and 有参构造
  //setter and getter ,toString
}</code></pre>
<p>4、创建 dao 接口和 mapper 文件</p>
<ul>
<li>1、StudentDao 接口</li>
</ul>
<pre><code class="java">public interface StudentDao{
  int insertStudent(Student student);
  List&lt;Student&gt; selectStudents();
}</code></pre>
<ul>
<li>2、StudentDao.xml</li>
</ul>
<pre><code class="xml">&lt;mapper namespace=&quot;com.bjpowernode.dao.StudentDao&quot;&gt;
    &lt;insert id=&quot;insertStudent&quot; &gt;
        insert into student values (#{id},#{name},#{email},#{age})
    &lt;/insert&gt;
    &lt;select id=&quot;selectStudents&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt;
        select id,name,email,age from student order by id desc
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<p>5、创建主配置文件 mybatis.xml</p>
<pre><code class="xml">&lt;configuration&gt;
    &lt;!--设置别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--name:实体类所在的包名--&gt;
        &lt;package name=&quot;com.bjpowernode.domain&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--sql mapper（sql 映射文件）的位置--&gt;
    &lt;mappers&gt;
        &lt;!--
            name ：是包名，这个包中的所有mapper.xml 文件一次都能加载
        --&gt;
        &lt;package name=&quot;com.bjpowernode.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<p>6、创建 service 接口和其实现类，属性是 dao</p>
<pre><code class="java">public interface SomeService{
  int addStudent(Student student);
  List&lt;Student&gt; queryStudents();
}</code></pre>
<pre><code class="java">public class SomeServiceImpl extends SomeService{
  private StudentDao studentDao;
  //set注入赋值
  public void setStudentDao(StudentDao studentDao){
    this.studentDao = studentDao;
  }
  @Override
  public int addStudent(Student student){
    int nums = studentDao.insertStudent(student);
    return nums;
  }
  @Override
  public List&lt;Student&gt; queryStudents(){
    List&lt;Student&gt; students = studentDao.selectStudent();
    return students;
  }
}</code></pre>
<p>7、创建 spring 的配置文件</p>
<pre><code class="properties">jdbc.url=jdbc:mysql://localhost:3306/springdb?useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=shixiang
jdbc.maxActive=20</code></pre>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;
&lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destory-method=&quot;close&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
  &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
  &lt;property name=&quot;maxActivce&quot; value=&quot;${jdbc.maxActive}&quot; /&gt;
&lt;/bean&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt;
  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt;
&lt;/bean&gt;
&lt;bena class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; &gt;
    &lt;property name=&quot;sqlSessionFactoryBenaName&quot; value=&quot;sqlSessionFactory&quot; /&gt;
  &lt;property name=&quot;basePackage&quot; value=&quot;com.bjpowernode.dao&quot; /&gt;
&lt;/bena&gt;
&lt;bean id=&quot;studentService&quot; class=&quot;com.bjpowernode.service.impl.SomeserviceImpl&quot; &gt;
    &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;/&gt;
&lt;/bean&gt;</code></pre>
<p>8、创建一个 jsp 发起请求，有参数 id，name，email，age</p>
<ul>
<li>1.index.jsp</li>
</ul>
<pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;注册学生&lt;/p&gt;
    &lt;form action=&quot;reg&quot; method=&quot;post&quot;&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;td&gt;id&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;姓名&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;email&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;age&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;注册学生&quot;&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>9、创建一个Servlet，接收请求参数，调用 Service，调用dao 完成注册</p>
<ul>
<li>1、RegisterServlet</li>
</ul>
<pre><code class="java">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String strId = request.getParameter(&quot;id&quot;);
        String strName = request.getParameter(&quot;name&quot;);
        String strEmail = request.getParameter(&quot;email&quot;);
        String strAge = request.getParameter(&quot;age&quot;);

        //创建 spring 的容器对象
        //String config = &quot;spring.xml&quot;;
        //ApplicationContext ac = new ClassPathXmlApplicationContext(config);

        WebApplicationContext ac = null;
        //获取ServletContext 中的容器对象，创建好的容器对象，拿来就用
        /*String key = WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE;
        Object attr = getServletContext().getAttribute(key);
        if (attr != null){
            ac = (WebApplicationContext) attr;
        }*/

        //使用框架中的方法，获取容器对象
        ServletContext sc = getServletContext();
        ac = WebApplicationContextUtils.getRequiredWebApplicationContext(sc);
        System.out.println(&quot;容器对象的信息 ====== &quot; + ac);

        //获取 service
        SomeService service = (SomeService) ac.getBean(&quot;studentService&quot;);
        Student student = new Student();
        student.setId(Integer.parseInt(strId));
        student.setName(strName);
        student.setEmail(strEmail);
        student.setAge(Integer.valueOf(strAge));  //valueOf 底层调的就是 parseInt()，一样的作用
        service.addStudent(student);

        //给一个页面
        request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(request,response);
    }
}</code></pre>
<ul>
<li>2、配置 web.xml文件</li>
</ul>
<pre><code class="xml">&lt;servlet&gt;
        &lt;servlet-name&gt;RegisterServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.bjpowernode.controller.RegisterServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;RegisterServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/reg&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!--注册监听器 ContextLoaderListener
        监听器被创建对象后，会读取/WEB-INF/spring.xml
        为什么要读取文件：因为在监听器中要创建 ApplicationContext 对象，
        需要加载配置文件。
        /WEB-INF/applicationContext.xml就是监听器默认读取的 spring 配置文件路径

        可以修改默认的文件位置，使用 context-param 重新指定文件的位置

        配置监听器：目的是创建容器对象，创建了容器对象，就能把 spring.xml 配置文件
        中的所有对象都创建好。用户发起请求就可以直接使用对象了。
    --&gt;
    &lt;context-param&gt;
        &lt;!--contextConfigLocation:表示配置文件的路径--&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;!--自定义配置文件的路径--&gt;
        &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;</code></pre>
<p>10、创建一个jsp作为显示结果页面</p>
<ul>
<li>1、result.jsp</li>
</ul>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
result.jsp 注册成功
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="总结：使用-Spring-的监听器-ContextLoaderListener步骤"><a href="#总结：使用-Spring-的监听器-ContextLoaderListener步骤" class="headerlink" title="总结：使用 Spring 的监听器 ContextLoaderListener步骤"></a>总结：使用 <strong>Spring</strong> 的监听器 <strong>ContextLoaderListener</strong>步骤</h4><p>1、maven 依赖 pom.xml</p>
<pre><code class="xml">&lt;dependency&gt; 
  &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;     
  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>2、web.xml 中注册监听器 <strong>ContextLoaderListener</strong></p>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
<p>3、指定 <strong>Spring</strong> 配置文件的位置&lt;context-param&gt;</p>
<pre><code class="xml">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre>
<p>4、Servlet 中获取spring 容器对象</p>
<p>1.通过WebApplicationContextUtils获取</p>
<pre><code class="java">WebApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext());</code></pre>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanQR.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2021/09/25/MySQL基础/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                MySQL基础</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2018/12/12/Hexo-Theme-Sakura/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://static.2heng.xin/wp-content/uploads//2019/02/wallhaven-672007-1-1024x576.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://static.2heng.xin/wp-content/uploads//2019/02/wallhaven-672007-1-1024x576.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                Hexo-Theme-Sakura</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz",
        appKey: "mgOpfzbkHYqU92CV4IDlAUHQ",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>




      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="" class="profile gravatar"><img src="" itemprop="image" alt="" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="" itemprop="url" rel="author"></a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i></p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 TenIncense<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">さくら荘そのTenIncense</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/honjun" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="http://weibo.com/mashirozx?is_all=1" class="fa fa-weibo" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
        <a href="https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/悦读/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/图集/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  图集
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Lab
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/client/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-android faa-vertical" aria-hidden="true"></i>
            客户端
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>